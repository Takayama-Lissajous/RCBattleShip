<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EMAC Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EMAC Functions<div class="ingroups"><a class="el" href="group___c_s_l___e_m_a_c___a_p_i.html">EMAC</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga245a98e37da49238aa5faeb26811b9ae"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga245a98e37da49238aa5faeb26811b9ae">EMAC_enumerate</a> (void)</td></tr>
<tr class="memdesc:ga245a98e37da49238aa5faeb26811b9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">EMACInterfaces EMAC Interfaces.  <a href="#ga245a98e37da49238aa5faeb26811b9ae">More...</a><br /></td></tr>
<tr class="separator:ga245a98e37da49238aa5faeb26811b9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ee8baa9e40377ae4c6d1473f5e78b5"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaf3ee8baa9e40377ae4c6d1473f5e78b5">EMAC_open</a> (int instNum, Handle hApplication, <a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#gad9d19b1894e0257f3f6040967dd9c6ce">EMAC_Config</a> *pEMACConfig, Handle hEMAC, Handle hCore)</td></tr>
<tr class="separator:gaf3ee8baa9e40377ae4c6d1473f5e78b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0d03e641aee2c2f9391b67b674e38d"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga8a0d03e641aee2c2f9391b67b674e38d">EMAC_commonInit</a> (int instNum, <a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#ga3ffa3f0f130a3f7739fd273ab1d07195">EMAC_Common_Config</a> *pEMACCommonConfig, Handle hEMAC)</td></tr>
<tr class="separator:ga8a0d03e641aee2c2f9391b67b674e38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e786ab4336289fd7e37c66ace511ee5"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga1e786ab4336289fd7e37c66ace511ee5">EMAC_coreInit</a> (Handle hEMAC, Handle hApplication, <a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#ga7734a7a1fd8915236eba4c731905b1ed">EMAC_Core_Config</a> *pEMACCoreConfig, Handle hCore)</td></tr>
<tr class="separator:ga1e786ab4336289fd7e37c66ace511ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc0dcc485e59fa30550b404e8d3ad7e4"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gacc0dcc485e59fa30550b404e8d3ad7e4">EMAC_commonDeInit</a> (Handle hEMAC)</td></tr>
<tr class="separator:gacc0dcc485e59fa30550b404e8d3ad7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad730ad41b627bf2591d0479b70f9e8"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gafad730ad41b627bf2591d0479b70f9e8">EMAC_coreDeInit</a> (Handle hEMAC)</td></tr>
<tr class="separator:gafad730ad41b627bf2591d0479b70f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25f21dd0501b5e9ee43da614a241549"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaa25f21dd0501b5e9ee43da614a241549">EMAC_close</a> (Handle hEMAC)</td></tr>
<tr class="separator:gaa25f21dd0501b5e9ee43da614a241549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb88ea5cc6a8628bd16d2e8e15f80a2"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga3cb88ea5cc6a8628bd16d2e8e15f80a2">EMAC_getStatus</a> (Handle hEMAC, <a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#ga99b6859b09af9d53d9ba993470b95d53">EMAC_Status</a> *pStatus)</td></tr>
<tr class="separator:ga3cb88ea5cc6a8628bd16d2e8e15f80a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca2d4ecc71ab8bc37fe65bc8140c2a2f"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaca2d4ecc71ab8bc37fe65bc8140c2a2f">EMAC_setReceiveFilter</a> (Handle hEMAC, Uint32 ReceiveFilter, Uint8 masterChannel)</td></tr>
<tr class="separator:gaca2d4ecc71ab8bc37fe65bc8140c2a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3111958e51b9e6abe89fa29b067b127"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gad3111958e51b9e6abe89fa29b067b127">EMAC_getReceiveFilter</a> (Handle hEMAC, Uint32 *pReceiveFilter)</td></tr>
<tr class="separator:gad3111958e51b9e6abe89fa29b067b127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0ddf4bbacc7745cabd01ea999398cd"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gacf0ddf4bbacc7745cabd01ea999398cd">EMAC_getStatistics</a> (Handle hEMAC, <a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#gac4d8007d72a9171e6d1e1348e35314ad">EMAC_Statistics</a> *pStatistics)</td></tr>
<tr class="separator:gacf0ddf4bbacc7745cabd01ea999398cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f47048ba24c989e34554331ab1b71f"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga62f47048ba24c989e34554331ab1b71f">EMAC_setMulticast</a> (Handle hEMAC, Uint32 AddrCnt, Uint8 *pMCastList)</td></tr>
<tr class="separator:ga62f47048ba24c989e34554331ab1b71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed83349bb1b9d3782ce9aed6ed24eda3"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaed83349bb1b9d3782ce9aed6ed24eda3">EMAC_sendPacket</a> (Handle hEMAC, <a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#ga31cb622a374c082f06337682722632d9">EMAC_Pkt</a> *pPkt)</td></tr>
<tr class="separator:gaed83349bb1b9d3782ce9aed6ed24eda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0b05170729e94c9cf96f8505244ddc"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga1c0b05170729e94c9cf96f8505244ddc">EMAC_RxServiceCheck</a> (Handle hEMAC)</td></tr>
<tr class="separator:ga1c0b05170729e94c9cf96f8505244ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2714cebf928b71d348a178e45a2d2a82"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga2714cebf928b71d348a178e45a2d2a82">EMAC_TxServiceCheck</a> (Handle hEMAC)</td></tr>
<tr class="separator:ga2714cebf928b71d348a178e45a2d2a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8e5dbe4975215e8e808710a9c88058a"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gae8e5dbe4975215e8e808710a9c88058a">EMAC_timerTick</a> (Handle hEMAC)</td></tr>
<tr class="separator:gae8e5dbe4975215e8e808710a9c88058a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006914d45ebb8d04380f73299e383cc4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga006914d45ebb8d04380f73299e383cc4">EMAC_txChannelTeardown</a> (Handle hEMAC, Uint32 val)</td></tr>
<tr class="separator:ga006914d45ebb8d04380f73299e383cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga339efc6e52c1772e053f7cf959027a28"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga339efc6e52c1772e053f7cf959027a28">EMAC_rxChannelTeardown</a> (Handle hEMAC, Uint32 val)</td></tr>
<tr class="separator:ga339efc6e52c1772e053f7cf959027a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa25f21dd0501b5e9ee43da614a241549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_close </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaa25f21dd0501b5e9ee43da614a241549">EMAC_close()</a></b> </p>
<p><b>Description</b> <br />
 When called by a core, free all pending transmit and receive packets, and release Tx/Rx channels used and MAC addresses assigned via.calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gafad730ad41b627bf2591d0479b70f9e8">EMAC_coreDeInit()</a>. When called by the master core, furhter close the EMAC peripheral indicated by the supplied EMAC device handle, shutdown both send and receive operations, and bring down the MDIO link via calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gacc0dcc485e59fa30550b404e8d3ad7e4">EMAC_commonDeInit()</a>. The function returns zero on success, or an error code on failure.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC   handle to opened the EMAC device</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC_open (on the master core) or EMAC_commonInit function must be called before calling this API.</p>
<p><b> Post Condition </b> <br />
 For any core, the EMAC device will free all pending transmit and receive packets, release Tx/Rx channels used and MAC addresses assigned. For master core, the EMAC device will further shutdown both send and receive operations and bring down the MDIO link.</p>
<p><b>Example</b> </p><pre class="fragment">     EMAC_Config  ecfg;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;
     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...

     //Close the EMAC peripheral
     EMAC_close( &amp;EMACObj );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacc0dcc485e59fa30550b404e8d3ad7e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_commonDeInit </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gacc0dcc485e59fa30550b404e8d3ad7e4">EMAC_commonDeInit()</a></b> </p>
<p><b>Description</b> <br />
 Shut down EMAC peripheral indicated by the supplied EMAC device handle: tear down both send and receive operations, resets common configuration, and bring down the MDIO link. Called by the master core only. The function returns zero on success, or an error code on failure.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC       handle to opened the EMAC device</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC_open (on the master core) or EMAC_commonInit function must be called before calling this API.</p>
<p><b> Post Condition </b> <br />
 The EMAC device will shutdown both send and receive operations, resets common configuration, and bring down the MDIO link.</p>
<p><b>Example</b> </p><pre class="fragment">     EMAC_Config     ecfg;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;
     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...

     //Shut down EMAC operation for a core
     EMAC_coreDeInit( &amp;EMACObj );

     ...

     //Shut down the EMAC peripheral
     EMAC_commonDeInit( &amp;EMACObj );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8a0d03e641aee2c2f9391b67b674e38d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_commonInit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#ga3ffa3f0f130a3f7739fd273ab1d07195">EMAC_Common_Config</a> *&#160;</td>
          <td class="paramname"><em>pEMACCommonConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga8a0d03e641aee2c2f9391b67b674e38d">EMAC_commonInit()</a></b> </p>
<p><b>Description</b> <br />
 Open the EMAC peripheral at the given physical index and perform initialization common to all the cores, including resetting the EMAC control module and stats, initializing DMA, configuring common registers such as the MACCONTROL register, initializing MDIO, and etc. This function has to be called only once by the master core.</p>
<p>The calling application must supply an operating configuration. Data from this config structure is copied into the device's internal instance structure so the structure may be discarded after <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga8a0d03e641aee2c2f9391b67b674e38d">EMAC_commonInit()</a> returns. In order to change an item in the configuration, the EMAC device must be de-initialized by <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gacc0dcc485e59fa30550b404e8d3ad7e4">EMAC_commonDeInit()</a> and then re-initialized by calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga8a0d03e641aee2c2f9391b67b674e38d">EMAC_commonInit()</a> with the new configuration.</p>
<p>A valid EMAC device handle should be passed to this API to which the configuration and operating state of the EMAC device common to all the cores will be written. The EMAC device structure for the handle needs to be initialized before calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga8a0d03e641aee2c2f9391b67b674e38d">EMAC_commonInit()</a>.</p>
<p>The default receive filter prevents normal packets from being received until the receive filter is specified by calling EMAC_receiveFilter().</p>
<p>A device reset is achieved by calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gacc0dcc485e59fa30550b404e8d3ad7e4">EMAC_commonDeInit()</a> followed by <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga8a0d03e641aee2c2f9391b67b674e38d">EMAC_commonInit()</a>.</p>
<p>The function returns zero on success, or an error code on failure.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     instNum           EMAC Peripheral ID to identify the EMAC controller to be
                       initialized.
     pEMACCommonConfig EMAC's configuration common to all cores.
     hEMAC             Handle to the EMAC device which needs to be initialized.</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Open the EMAC peripheral at the given physical index and perform initialization common to all the cores.</p>
<p><b>Example</b> </p><pre class="fragment">     EMAC_Device            EMACObj; // In multi-core scenario, this must be placed in shared memory,
                                        and initialized by application. Refer to "emac_core_restart"
                                        example project for more details.

     EMAC_Common_Config     commonCfg;

     // Initialize our EMAC Dev structure.
     memset(&amp;EMACObj, 0, sizeof(EMAC_Device));

     // Not using the MDIO configuration
     commonCfg.UseMdio = 0;
     // core 0 is master core performing common initialization of the EMAC
     commonCfg.CoreNum = 0; 
     //packet size
     commonCfg.PktMTU = 1600;

     // Setup the EMAC local loopback
     commonCfg.ModeFlags      = EMAC_CONFIG_MODEFLG_MACLOOPBACK | EMAC_CONFIG_MODEFLG_GMIIEN
                              | EMAC_CONFIG_MODEFLG_FULLDUPLEX;
     commonCfg.MdioModeFlags  = MDIO_MODEFLG_FD1000;

     //Common initialization of the EMAC peripheral
     EMAC_commonInit(0, &amp;commonCfg, &amp;EMACObj);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafad730ad41b627bf2591d0479b70f9e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_coreDeInit </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gafad730ad41b627bf2591d0479b70f9e8">EMAC_coreDeInit()</a></b> </p>
<p><b>Description</b> <br />
 Shut down EMAC operation for a core. When called, free all pending transmit and receive packets for the core, and release Tx/Rx channels used and MAC addresses assigned The function returns zero on success, or an error code on failure.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC       handle to opened the EMAC device</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC_open (on the master core) or EMAC_commonInit function must be called before calling this API.</p>
<p><b> Post Condition </b> <br />
 The EMAC device will free all pending transmit and receive packets for the core, and also release Tx/Rx channels used and MAC addresses assigned.</p>
<p><b>Example</b> </p><pre class="fragment">     EMAC_Config     ecfg;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...

     //Shut down EMAC operation for a core
     EMAC_coreDeInit( &amp;EMACObj );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1e786ab4336289fd7e37c66ace511ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_coreInit </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hApplication</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#ga7734a7a1fd8915236eba4c731905b1ed">EMAC_Core_Config</a> *&#160;</td>
          <td class="paramname"><em>pEMACCoreConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hCore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga1e786ab4336289fd7e37c66ace511ee5">EMAC_coreInit()</a></b> </p>
<p><b>Description</b> <br />
 Core specific initialization to use the EMAC peripheral at the given physical index when every core starts/restarts. The per core configuration includes setting up Tx/Rx channels, allocating MAC addresses, enabling interrupts in the EMAC control module for the channels that this core uses, and etc.</p>
<p>The calling application must supply an operating configuration. Data from this config structure is copied into the device's internal instance structure so the structure may be discarded after <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga1e786ab4336289fd7e37c66ace511ee5">EMAC_coreInit()</a> returns. In order to change an item in the configuration, the core must be de-initialized from the EMAC device by calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gafad730ad41b627bf2591d0479b70f9e8">EMAC_coreDeInit()</a> and then re-initialized by calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga1e786ab4336289fd7e37c66ace511ee5">EMAC_coreInit()</a> with the new configuration.</p>
<p>A valid EMAC core instance handle should be passed to this API to which the operating state of the EMAC device specific to individual cores will be written. The EMAC core instance structure for the handle needs to be initialized before calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga1e786ab4336289fd7e37c66ace511ee5">EMAC_coreInit()</a>.</p>
<p>The application layer may pass in an hApplication callback handle, that will be supplied by the EMAC device for the core when making calls to the core's application callback functions.</p>
<p>A valid EMAC device handle should be passed to this API to which the per core configuration and operating state of the EMAC device will be written.</p>
<p>A core reset for EMAC operation is achieved by calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gafad730ad41b627bf2591d0479b70f9e8">EMAC_coreDeInit()</a> followed by <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga1e786ab4336289fd7e37c66ace511ee5">EMAC_coreInit()</a>.</p>
<p>The function returns zero on success, or an error code on failure.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC           Handle to the EMAC device which needs to be initialized.
     hApplication    Application handle
     pEMACCoreConfig EMAC's configuration specific to the core
     hCore           Handle to the EMAC core instance which needs to be initialized.</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 Before calling this API, EMAC_commonInit function must be called on the master core and then EMAC_coreDeInit must be called for this particular core.</p>
<p><b> Post Condition </b> <br />
 Core specific initialization to use the EMAC peripheral at the given physical index.</p>
<p><b>Example</b> </p><pre class="fragment">     #define MASTER_CORE 0           // Which core is responsible for EMAC common initialization

     Uint32                 coreNum;
     Uint32                 i = 0, j = 0;
     EMAC_Common_Config     commonCfg;
     EMAC_Core_Config       coreCfg;
     EMAC_Device            EMACObj;
     EMAC_Core              EMACCore;
     EMAC_AddrConfig*       addrCfg;

     ...

     if (coreNum == MASTER_CORE)
        {
         // Initialize our EMAC Dev structure.
         memset(&amp;EMACObj, 0, sizeof(EMAC_Device));
         // Common initialization of the EMAC peripheral
         EMAC_commonInit(0, &amp;commonCfg, &amp;EMACObj);
        }
     // Initialize EMAC core instance structure.
     memset(&amp;EMACCore, 0, sizeof(EMAC_Core));

     //Total 3 MAC addresses allocated for the receive channel 
     coreCfg.NumOfMacAddrs = 3;
     // selects CPPI RAM for Descriptor memory 
     coreCfg.DescBase = EMAC_DESC_BASE_CPPI;

     coreCfg.RxMaxPktPool              = 8;
     coreCfg.pfcbGetPacket             = &amp;GetPacket;
     coreCfg.pfcbFreePacket            = &amp;FreePacket;
     coreCfg.pfcbRxPacket              = &amp;RxPacket;
     coreCfg.pfcbStatus                = &amp;StatusUpdate;
     coreCfg.pfcbStatistics            = &amp;StatisticsUpdate;

     switch(coreNum) {
         default:
         case 0:                   // core 0 use channel 0 
             coreCfg.ChannelInfo.TxChanEnable = 1;
             coreCfg.ChannelInfo.RxChanEnable = 1;
             break;
         case 1:                   // core 1 use channel 1 
             coreCfg.ChannelInfo.TxChanEnable = 2;
             coreCfg.ChannelInfo.RxChanEnable = 2;
             break;
         case 2:                   // core 2 use channel 2 
             coreCfg.ChannelInfo.TxChanEnable = 4;
             coreCfg.ChannelInfo.RxChanEnable = 4;
             break;
     }

     //Configure the number of MAC addresses per channel
     //Hardware gives support for 32 MAC addresses for 8 receive channels
     //Here total 9 MAC addresses are assigned to 3 receive channels
     //3 MAC addresses per channel
     //MAC addresses and channels allocated are like mentioned below
     //  core no           channel assigned       MAC address
     //   core0         channel 0        00.01.02.03.04.05
     //                                                     10.11.12.13.14.15
     //                                                             20.21.22.23.24.25(address used for loopback test)
     //
     //   core1         channel 1               30.31.32.33.34.35
     //                                                                 40.41.42.43.44.45
     //                                                                 50.51.52.53.54.55(address used for loopback test)
     //
     //  core2         channel 2                60.61.62.63.64.65
     //                                                                 70.71.72.73.74.75
     //                                                                 80.81.82.83.84.85(address used for loopback test)

     coreCfg.MacAddr = (EMAC_AddrConfig **)
                       malloc(coreCfg.NumOfMacAddrs * sizeof(EMAC_AddrConfig *));

     for (j=0; j&lt;coreCfg.NumOfMacAddrs; j++){
         coreCfg.MacAddr[j] = (EMAC_AddrConfig *)malloc(sizeof(EMAC_AddrConfig));
     }

     for(j=0; (Uint8)j&lt;(coreCfg.NumOfMacAddrs); j++){
         addrCfg = coreCfg.MacAddr[j];
         addrCfg-&gt;ChannelNum = coreNum;
         for (i=0; i&lt;6; i++)
         {
             addrCfg-&gt;Addr[i] = j * 0x10 + i + coreNum * 0x30;
         }
     }

     EMAC_coreDeInit(&amp;EMACObj);
     EMAC_coreInit(&amp;EMACObj, (Handle)0x12345678, &amp;coreCfg, &amp;EMACCore);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga245a98e37da49238aa5faeb26811b9ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_enumerate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EMACInterfaces EMAC Interfaces. </p>
<p>Interfaces for EMAC module.</p>
<dl class="section user"><dt></dt><dd><b> Note: </b>The application is charged with verifying that only one of the following API calls may be executing at a given time across all threads and all interrupt functions. </dd></dl>
<dl class="section user"><dt></dt><dd>Hence, when used in an multitasking environment, no EMAC function may be called while another EMAC function is operating on the same device handle in another thread. It is the responsibility of the application to assure adherence to this restriction. ============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga245a98e37da49238aa5faeb26811b9ae" title="EMACInterfaces EMAC Interfaces. ">EMAC_enumerate()</a></b> </dd></dl>
<p><b>Description</b> <br />
 Enumerates the EMAC peripherals installed in the system and returns an integer count. The EMAC devices are enumerated in a consistent fashion so that each device can be later referenced by its physical index value ranging from "1" to "n" where "n" is the count returned by this function.</p>
<p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">     EMAC_enumerate( );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad3111958e51b9e6abe89fa29b067b127"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_getReceiveFilter </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pReceiveFilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gad3111958e51b9e6abe89fa29b067b127">EMAC_getReceiveFilter()</a></b> </p>
<p><b>Description</b> <br />
 Called to get the current packet filter setting for received packets. The filter values are the same as those used in <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaca2d4ecc71ab8bc37fe65bc8140c2a2f">EMAC_setReceiveFilter()</a>.</p>
<p>The current filter value is written to the pointer supplied in pReceiveFilter.</p>
<p>The function returns zero on success, or an error code on failure.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC           handle to the opened EMAC device
     pReceiveFilter  Current receive packet filter</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC peripheral instance must be opened before calling this API and must be set the packet filter value.</p>
<p><b> Post Condition </b> <br />
 The current filter value is written to the pointer supplied</p>
<p><b>Example</b> </p><pre class="fragment">     #define EMAC_RXFILTER_DIRECT       1
     EMAC_Config     ecfg;
     Uint32          pReceiveFilter;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...

     EMAC_setReceiveFilter(&amp;EMACObj, EMAC_RXFILTER_DIRECT, 0);

     EMAC_getReceiveFilter(&amp;EMACObj, &amp;pReceiveFilter );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacf0ddf4bbacc7745cabd01ea999398cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_getStatistics </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#gac4d8007d72a9171e6d1e1348e35314ad">EMAC_Statistics</a> *&#160;</td>
          <td class="paramname"><em>pStatistics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gacf0ddf4bbacc7745cabd01ea999398cd">EMAC_getStatistics()</a></b> </p>
<p><b>Description</b> <br />
 Called to get the current device statistics. The statistics structure contains a collection of event counts for various packet sent and receive properties. Reading the statistics also clears the current statistic counters, so the values read represent a delta from the last call.</p>
<p>The statistics information is copied into the structure pointed to by the pStatistics argument.</p>
<p>The function returns zero on success, or an error code on failure.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC       handle to the opened EMAC device
     pStatistics Get the device statistics</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC peripheral instance must be opened before calling this API</p>
<p><b> Post Condition </b></p><ol type="1">
<li>Statistics are read for various packects sent and received.</li>
<li>Reading the statistics also clears the current statistic counters, so the values read represent a delta from the last call.</li>
</ol>
<p><b>Example</b> </p><pre class="fragment">     EMAC_Config      ecfg;
     EMAC_Statistics  pStatistics;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...

     EMAC_getStatistics(&amp;EMACObj, &amp;pStatistics );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3cb88ea5cc6a8628bd16d2e8e15f80a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_getStatus </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#ga99b6859b09af9d53d9ba993470b95d53">EMAC_Status</a> *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga3cb88ea5cc6a8628bd16d2e8e15f80a2">EMAC_getStatus()</a></b> </p>
<p><b>Description</b> <br />
 Called to get the current status of the device. The device status is copied into the supplied data structure.</p>
<p>The function returns zero on success, or an error code on failure.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC   handle to the opened EMAC device
     pStatus Status of the EMAC</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC peripheral instance must be opened before calling this API.</p>
<p><b> Post Condition </b> <br />
 The current status of the device is copied into the supplied data structure.</p>
<p><b>Example</b> </p><pre class="fragment">     EMAC_Status     pStatus;
     EMAC_Config  ecfg;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...

     EMAC_getStatus( &amp;EMACObj, &amp;pStatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf3ee8baa9e40377ae4c6d1473f5e78b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_open </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hApplication</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#gad9d19b1894e0257f3f6040967dd9c6ce">EMAC_Config</a> *&#160;</td>
          <td class="paramname"><em>pEMACConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hCore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaf3ee8baa9e40377ae4c6d1473f5e78b5">EMAC_open()</a></b> </p>
<p><b>Description</b> <br />
 Opens the EMAC peripheral at the given physical index and initializes it to an embryonic state.</p>
<p>The calling application must supply operating configurations that includes the ones common to all the cores if on the master core and also those specific to individual cores. The EMAC device must be closed and then re-opened when new configuration is required.</p>
<p>The application layer may pass in an hApplication callback handle, that will be supplied by the EMAC device for the core when making calls to the core's application callback functions.</p>
<p>A valid EMAC device handle should be passed to this API to which the configuration and operating state of the EMAC device will be written.</p>
<p>A valid EMAC core instance handle should be passed to this API to which the operating state of the EMAC device specific to individual cores will be written.</p>
<p>The default receive filter prevents normal packets from being received until the receive filter is specified by calling EMAC_receiveFilter().</p>
<p>By calling <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaa25f21dd0501b5e9ee43da614a241549">EMAC_close()</a> followed by <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaf3ee8baa9e40377ae4c6d1473f5e78b5">EMAC_open()</a> on the master core, EMAC device reset is achieved. When the same sequence is called on a non-master core, a core reset for EMAC operation is achieved</p>
<p>The function returns zero on success, or an error code on failure.</p>
<p>Possible error codes include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     instNum         EMAC Peripheral ID to identify the EMAC controller to be'
                     initialized.
     hApplication    Application handle
     pEMACConfig     EMAC's configuration structure
     hEMAC           Handle to the EMAC device which needs to be initialized.
     hCore           Handle to the EMAC core instance which needs to be initialized.</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Opens the EMAC peripheral at the given physical index and initializes it.</p>
<p><b>Example</b> </p><pre class="fragment">     #define MASTER_CORE 0           // Which core is responsible for EMAC common initialization

     EMAC_Device            EMACObj; // In multi-core scenario, this must be placed in shared memory,
                                        and initialized by application.
     EMAC_Core              EMACCore;// In multi-core scenario, it is desirable to place EMACCore in local memory
                                        so that run-time cache operation on EMACCore can be avoided
     Uint32                 coreNum;
     Uint32                 i = 0, j = 0;
     EMAC_Config            ecfg;
     EMAC_AddrConfig*       addrCfg;

     // Initialize our EMAC Dev structure.
         if(coreNum == MASTER_CORE) 
         {
                memset(&amp;EMACObj, 0, sizeof(EMAC_Device));

                // Not using the MDIO configuration
                ecfg.EMACCommonConfig.UseMdio = 0;
                // core 0 is master core performing common initialization of the EMAC
                ecfg.EMACCommonConfig.CoreNum = 0; 
                //packet size
                ecfg.EMACCommonConfig.PktMTU = 1600;

                // Setup the EMAC local loopback
                ecfg.EMACCommonConfig.ModeFlags      = EMAC_CONFIG_MODEFLG_MACLOOPBACK | EMAC_CONFIG_MODEFLG_GMIIEN
                                                                                         | EMAC_CONFIG_MODEFLG_FULLDUPLEX;
                ecfg.EMACCommonConfig.MdioModeFlags  = MDIO_MODEFLG_FD1000;
        }

     // Initialize EMAC core instance structure.
     memset(&amp;EMACCore, 0, sizeof(EMAC_Core));

     //Total 3 MAC addresses allocated for the receive channel 
     ecfg.EMACCoreConfig.NumOfMacAddrs = 3;
     // selects CPPI RAM for Descriptor memory 
     ecfg.EMACCoreConfig.DescBase = EMAC_DESC_BASE_CPPI;

     ecfg.EMACCoreConfig.RxMaxPktPool              = 8;
     ecfg.EMACCoreConfig.pfcbGetPacket             = &amp;GetPacket;
     ecfg.EMACCoreConfig.pfcbFreePacket            = &amp;FreePacket;
     ecfg.EMACCoreConfig.pfcbRxPacket              = &amp;RxPacket;
     ecfg.EMACCoreConfig.pfcbStatus                = &amp;StatusUpdate;
     ecfg.EMACCoreConfig.pfcbStatistics            = &amp;StatisticsUpdate;

     switch(coreNum) {
         default:
         case 0:                   // core 0 use channel 0 
             ecfg.EMACCoreConfig.ChannelInfo.TxChanEnable = 1;
             ecfg.EMACCoreConfig.ChannelInfo.RxChanEnable = 1;
             break;
         case 1:                   // core 1 use channel 1 
             ecfg.EMACCoreConfig.ChannelInfo.TxChanEnable = 2;
             ecfg.EMACCoreConfig.ChannelInfo.RxChanEnable = 2;
             break;
         case 2:                   // core 2 use channel 2 
             ecfg.EMACCoreConfig.ChannelInfo.TxChanEnable = 4;
             ecfg.EMACCoreConfig.ChannelInfo.RxChanEnable = 4;
             break;
     }

     //Configure the number of MAC addresses per channel
     //Hardware gives support for 32 MAC addresses for 8 receive channels
     //Here total 9 MAC addresses are assigned to 3 receive channels
     //3 MAC addresses per channel
     //MAC addresses and channels allocated are like mentioned below
     //  core no           channel assigned       MAC address
     //   core0         channel 0        00.01.02.03.04.05
     //                                                     10.11.12.13.14.15
     //                                                             20.21.22.23.24.25(address used for loopback test)
     //
     //   core1         channel 1               30.31.32.33.34.35
     //                                                                 40.41.42.43.44.45
     //                                                                 50.51.52.53.54.55(address used for loopback test)
     //
     //  core2         channel 2                60.61.62.63.64.65
     //                                                                 70.71.72.73.74.75
     //                                                                 80.81.82.83.84.85(address used for loopback test)

     ecfg.EMACCoreConfig.MacAddr = (EMAC_AddrConfig **)
                                   malloc(ecfg.EMACCoreConfig.NumOfMacAddrs * sizeof(EMAC_AddrConfig *));

     for (j=0; j&lt;ecfg.EMACCoreConfig.NumOfMacAddrs; j++){
         ecfg.EMACCoreConfig.MacAddr[j] = (EMAC_AddrConfig *)malloc(sizeof(EMAC_AddrConfig));
     }

     for(j=0; (Uint8)j&lt;(ecfg.EMACCoreConfig.NumOfMacAddrs); j++){
         addrCfg = ecfg.EMACCoreConfig.MacAddr[j];
         addrCfg-&gt;ChannelNum = coreNum;
         for (i=0; i&lt;6; i++)
         {
             addrCfg-&gt;Addr[i] = j * 0x10 + i + coreNum * 0x30;
         }
     }

     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga339efc6e52c1772e053f7cf959027a28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int EMAC_rxChannelTeardown </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMAC_rxChannelTeardown</b> </p>
<p><b>Description</b> Tear down selective receive channel/channels</p>
<p><b>Arguments</b> </p><pre class="fragment">         val        mask of selective rx channels to be torn down.
     hEMAC      handle to the opened EMAC device</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Tear down specific rx channels</p>
<p><b>Modifies</b> <br />
 EMAC registers</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32             val = EMAC_TEARDOWN_CHANNEL(0) | EMAC_TEARDOWN_CHANNEL(1);
     EMAC_Device        EMACObj;
     EMAC_Config        ecfg;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj);

     ...


     EMAC_rxChannelTeardown (&amp;EMACObj, val);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1c0b05170729e94c9cf96f8505244ddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_RxServiceCheck </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga1c0b05170729e94c9cf96f8505244ddc">EMAC_RxServiceCheck()</a></b> </p>
<p><b>Description</b> <br />
 This function should be called every time there is an EMAC device Rx interrupt. It maintains the status the EMAC.</p>
<p>Note that the application has the responsibility for mapping the physical device index to the correct EMAC_serviceCheck() function. If more than one EMAC device is on the same interrupt, the function must be called for each device.</p>
<p>Possible error codes include: EMAC_ERROR_INVALID - A calling parameter is invalid EMAC_ERROR_MACFATAL - Fatal error in the MAC - Call <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaa25f21dd0501b5e9ee43da614a241549">EMAC_close()</a></p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC       handle to the opened EMAC device</pre><p> <b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid <br />
 EMAC_ERROR_MACFATAL - Fatal error in the MAC - Call <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaa25f21dd0501b5e9ee43da614a241549">EMAC_close()</a></p>
<p><b> Pre Condition </b> <br />
 EMAC_open function must be called before calling this API.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">     static CSL_IntcContext context;
     static CSL_IntcEventHandlerRecord Record[13];
     static CSL_IntcObj intcEMACRx;
     static CSL_IntcHandle hIntcEMACRx;

     //CSL_IntcParam vectId1;
     CSL_IntcParam vectId2;

     CSL_IntcGlobalEnableState state;

     // Setup the global Interrupt
     context.numEvtEntries = 13;
     context.eventhandlerRecord = Record;

     // VectorID for the Event
     vectId2 = CSL_INTC_VECTID_6;

     CSL_intcInit(&amp;context);
     // Enable NMIs
     CSL_intcGlobalNmiEnable();
     // Enable Global Interrupts
     CSL_intcGlobalEnable(&amp;state);

     // Opening a handle for EMAC Rx interrupt
     hIntcEMACRx=CSL_intcOpen(&amp;intcEMACRx,CSL_INTC_EVENTID_6,&amp;vectId2,NULL);

     //Hook the ISRs
     CSL_intcHookIsr(vectId2,&amp;HwRxInt);

     CSL_intcHwControl(hIntcEMACRx, CSL_INTC_CMD_EVTENABLE, NULL);

     // This function is called when Rx interrupt occurs
     Void HwRxInt (void)
     {
         EMAC_Device     EMACObj;
         EMAC_Core       EMACCore;

         ...

         //Open the EMAC peripheral
         EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

         ...
             
         EMAC_RxServiceCheck(&amp;EMACObj);
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaed83349bb1b9d3782ce9aed6ed24eda3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_sendPacket </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_a_c___d_a_t_a_s_t_r_u_c_t.html#ga31cb622a374c082f06337682722632d9">EMAC_Pkt</a> *&#160;</td>
          <td class="paramname"><em>pPkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaed83349bb1b9d3782ce9aed6ed24eda3">EMAC_sendPacket()</a></b> </p>
<p><b>Description</b> <br />
 Sends a Ethernet data packet out the EMAC device. On a non-error return, the EMAC device takes ownership of the packet. The packet is returned to the application's free pool once it has been transmitted.</p>
<p>The function returns zero on success, or an error code on failure. When an error code is returned, the EMAC device has not taken ownership of the packet.</p>
<p>Possible error codes include: EMAC_ERROR_INVALID - A calling parameter is invalid EMAC_ERROR_BADPACKET - The packet structure is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC       handle to the opened EMAC device
     pPkt        EMAC packet structure</pre><p> <b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid <br />
 EMAC_ERROR_BADPACKET - The packet structure is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC peripheral instance must be opened and get a packet buffer from private queue</p>
<p><b> Post Condition </b> <br />
 Sends a ethernet data packet out the EMAC device and is returned to the application's free pool once it has been transmitted.</p>
<p><b>Example</b> </p><pre class="fragment">     #define EMAC_RXFILTER_DIRECT       1
     #define EMAC_PKT_FLAGS_SOP         0x80000000u
     #define EMAC_PKT_FLAGS_EOP         0x40000000u

     EMAC_Config     ecfg;
     EMAC_Pkt        *pPkt;
     Uint32          size, TxCount = 0;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...

     //set the receive filter
     EMAC_setReceiveFilter( &amp;EMACObj, EMAC_RXFILTER_DIRECT, 0);

     //Fill the packet options fields
     size = TxCount + 60;
     pPkt-&gt;Flags      = EMAC_PKT_FLAGS_SOP | EMAC_PKT_FLAGS_EOP;
     pPkt-&gt;ValidLen   = size;
     pPkt-&gt;DataOffset = 0;
     pPkt-&gt;PktChannel = 0;
     pPkt-&gt;PktLength  = size;
     pPkt-&gt;PktFrags   = 1;

     EMAC_sendPacket( &amp;EMACObj, pPkt );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga62f47048ba24c989e34554331ab1b71f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_setMulticast </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>AddrCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pMCastList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga62f47048ba24c989e34554331ab1b71f">EMAC_setMulticast()</a></b> </p>
<p><b>Description</b> <br />
 This function is called to install a list of multicast addresses for use in multicast address filtering. Each time this function is called, any current multicast configuration is discarded in favor of the new list. Thus a set with a list size of zero will remove all multicast addresses from the device.</p>
<p>Note that the multicast list configuration is stateless in that the list of multicast addresses used to build the configuration is not retained. Thus it is impossible to examine a list of currently installed addresses.</p>
<p>The addresses to install are pointed to by pMCastList. The length of this list in bytes is 6 times the value of AddrCnt. When AddrCnt is zero, the pMCastList parameter can be NULL.</p>
<p>The function returns zero on success, or an error code on failure. The multicast list settings are not altered in the event of a failure code.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC       handle to the opened EMAC device
     AddrCount   number of addresses to multicast
     pMCastList  pointer to the multi cast list</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC peripheral instance must be opened and set multicast filter.</p>
<p><b> Post Condition </b></p><ol type="1">
<li>Install a list of multicast addresses for use in multicast address filtering.</li>
<li>A set with a list size of zero will remove all multicast addresses from the device.</li>
</ol>
<p><b>Example</b> </p><pre class="fragment">     #define EMAC_RXFILTER_ALLMULTICAST 4

     Uint32          AddrCnt;
     Uint8           pMCastList;
     EMAC_Config     ecfg;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...

     EMAC_setReceiveFilter( &amp;EMACObj, EMAC_RXFILTER_ALLMULTICAST, 0);

     EMAC_setMulticast( &amp;EMACObj, AddrCnt, &amp;pMCastList );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaca2d4ecc71ab8bc37fe65bc8140c2a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_setReceiveFilter </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>ReceiveFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>masterChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaca2d4ecc71ab8bc37fe65bc8140c2a2f">EMAC_setReceiveFilter()</a></b> </p>
<p><b>Description</b> <br />
 Called to set the packet filter for received packets. The filtering level is inclusive, so BROADCAST would include both BROADCAST and DIRECTED (UNICAST) packets.</p>
<p>Available filtering modes include the following:</p><ul>
<li>EMAC_RXFILTER_NOTHING - Receive nothing</li>
<li>EMAC_RXFILTER_DIRECT - Receive only Unicast to local MAC addr</li>
<li>EMAC_RXFILTER_BROADCAST - Receive direct and Broadcast</li>
<li>EMAC_RXFILTER_MULTICAST - Receive above plus multicast in mcast list</li>
<li>EMAC_RXFILTER_ALLMULTICAST - Receive above plus all multicast</li>
<li>EMAC_RXFILTER_ALL - Receive all packets</li>
</ul>
<p>Note that if error frames and control frames are desired, reception of these must be specified in the device configuration.</p>
<p>The function returns zero on success, or an error code on failure.</p>
<p>Possible error code include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">      hEMAC           handle to the opened EMAC device
      ReceiveFilter   Filtering modes
      masterChannel   master core channel which receives broadcast frames</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC peripheral instance must be opened before calling this API</p>
<p><b> Post Condition </b> <br />
 Sets the packet filter for received packets</p>
<p><b>Example</b> </p><pre class="fragment">     #define EMAC_RXFILTER_DIRECT       1
     EMAC_Config  ecfg;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...

     EMAC_setReceiveFilter(&amp;EMACObj, EMAC_RXFILTER_DIRECT, 0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae8e5dbe4975215e8e808710a9c88058a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_timerTick </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gae8e5dbe4975215e8e808710a9c88058a">EMAC_timerTick()</a></b> </p>
<p><b>Description</b> <br />
 This function should be called for each device in the system on a periodic basis of 100mS (10 times a second). It is used to check the status of the EMAC and MDIO device, and to potentially recover from low Rx buffer conditions.</p>
<p>Strict timing is not required, but the application should make a reasonable attempt to adhere to the 100mS mark. A missed call should not be "made up" by making multiple sequential calls.</p>
<p>A "polling" driver (one that calls EMAC_serviceCheck() in a tight loop), must also adhere to the 100mS timing on this function.</p>
<p>Possible error codes include: EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC       handle to the opened EMAC device</pre><p><b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 EMAC peripheral instance must be opened</p>
<p><b> Post Condition </b> <br />
 Re-fill Rx buffer queue if needed and modifies EMAC CONTROL register.</p>
<p><b>Example</b> </p><pre class="fragment">     EMAC_Config ecfg;
     EMAC_Device     EMACObj;
     EMAC_Core       EMACCore;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

     ...


     EMAC_timerTick( &amp;EMACObj );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga006914d45ebb8d04380f73299e383cc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int EMAC_txChannelTeardown </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMAC_txChannelTeardown</b> </p>
<p><b>Description</b> Tear down selective transmit channel/channels</p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC      handle to the opened EMAC device
         val        mask of selective tx channels to be torn down.</pre><p><b> Return Value </b> EMAC_ERROR_INVALID - Invalid instance number</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Tear down specific tx channels</p>
<p><b>Modifies</b> <br />
 EMAC registers</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32             val = EMAC_TEARDOWN_CHANNEL(0) | EMAC_TEARDOWN_CHANNEL(1);
     EMAC_Device        EMACObj;
     EMAC_Config        ecfg;

     ...

     //Open the EMAC peripheral
     EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj);

     ...


     EMAC_txChannelTeardown (&amp;EMACObj, val);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2714cebf928b71d348a178e45a2d2a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 EMAC_TxServiceCheck </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hEMAC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#ga2714cebf928b71d348a178e45a2d2a82">EMAC_TxServiceCheck()</a></b> </p>
<p><b>Description</b> <br />
 This function should be called every time there is an EMAC device Tx interrupt. It maintains the status the EMAC.</p>
<p>Note that the application has the responsibility for mapping the physical device index to the correct EMAC_serviceCheck() function. If more than one EMAC device is on the same interrupt, the function must be called for each device.</p>
<p>Possible error codes include: EMAC_ERROR_INVALID - A calling parameter is invalid EMAC_ERROR_MACFATAL - Fatal error in the MAC - Call <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaa25f21dd0501b5e9ee43da614a241549">EMAC_close()</a></p>
<p><b>Arguments</b> </p><pre class="fragment">     hEMAC       handle to the opened EMAC device</pre><p> <b> Return Value </b> Success (0) <br />
 EMAC_ERROR_INVALID - A calling parameter is invalid <br />
 EMAC_ERROR_MACFATAL - Fatal error in the MAC - Call <a class="el" href="group___c_s_l___e_m_a_c___f_u_n_c_t_i_o_n.html#gaa25f21dd0501b5e9ee43da614a241549">EMAC_close()</a></p>
<p><b> Pre Condition </b> <br />
 EMAC_open function must be called before calling this API.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">     static CSL_IntcContext context;
     static CSL_IntcEventHandlerRecord Record[13];
     static CSL_IntcObj intcEMACTx;
     static CSL_IntcHandle hIntcEMACTx;

     //CSL_IntcParam vectId1;
     CSL_IntcParam vectId2;

     CSL_IntcGlobalEnableState state;

     // Setup the global Interrupt
     context.numEvtEntries = 13;
     context.eventhandlerRecord = Record;

     // VectorID for the Event
     vectId2 = CSL_INTC_VECTID_6;

     CSL_intcInit(&amp;context);
     // Enable NMIs
     CSL_intcGlobalNmiEnable();
     // Enable Global Interrupts
     CSL_intcGlobalEnable(&amp;state);

     // Opening a handle for EMAC Tx interrupt
     hIntcEMACTx=CSL_intcOpen(&amp;intcEMACTx,CSL_INTC_EVENTID_6,&amp;vectId2,NULL);

     //Hook the ISRs
     CSL_intcHookIsr(vectId2,&amp;HwTxInt);

     CSL_intcHwControl(hIntcEMACTx, CSL_INTC_CMD_EVTENABLE, NULL);

     // This function is called when Rx interrupt occurs
     Void HwTxInt (void)
     {
         EMAC_Device     EMACObj;
         EMAC_Core       EMACCore;

         ...

         //Open the EMAC peripheral
         EMAC_open(0, (Handle)0x12345678, &amp;ecfg, &amp;EMACObj, &amp;EMACCore);

         ...

         EMAC_TxServiceCheck(&amp;EMACObj);
     }</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
