3. Power, Reset, and Clock Management (PRCM)


<3.1> Device Power Management introduction

파워 매니지먼트는 어느 장치에서나 중요

사용자 만족을 위한 최대한의 퍼포먼스, 사용자의 최대한 디자인 유동성을 위해 (어플리케이션의 요구에따라)


<3.1.1> Device Power-Management Architectiure Building Blocks

파워 매니지먼트 프레임 워크는 3가지 자원으로 구성: clock, power, and voltage
-> 클락 도메인, 파워 도메인, 볼티지 도메인
(도메인은 같은 소스(클락소스, 파워스위치, 볼티지 소스)를 공유하는 모듈의 그룹)

도메인은 policy manager에 의해 관리 (도메인마다 매니저가 있다)


<3.1.1.1> Clock Management

PRCM 모듈이 클락을 관리

(클락)모듈에 전달되는 클락의 특성으로 2가지로 나뉨: interface clocks, functional clocks

* interface clocks 특성

모듈과 (device)interconnect 사이에서 커뮤니케이션
(클락)모듈의 interface 와 register에 공급


* funtional clocks 특성

기능적인 부분에 공급

몇 개의 funtional clock은 의무, 나머지는 옵션

작동하는데 의무적인 것이 필요
옵션은 카메라 같은 것을 사용할 때


<3.1.1.2> Module-Level Clock Management

클락이 활성화(activation) 되거나 닫는 것(gating)을 PRCM 모듈이 관리
그래서 PRCM 모듈은 클락이 언제 활성화 되고 언제 끝나는지 알고 있어야 한다.

PRCM 모듈의 2가지 클락 매니지 먼트

* Master standby protocol (called master moudule)

모듈이 장치 교류에서 상호교류를 시작
(PCRM모듈과 마스터 모듈 사이)

* Slave idle protocol (called slave module) 

모듈이 상호교류를 시작하지 않고 오직 마스터에 의해 시작된 상호교류에 대한 반응만
(PRCM모듈과 슬레이브 모듈 사이)


* Maser standby protocol 자세히

마스터 모듈이 상호교류를 시작
마스터 모듈이 클락(functional and interface)을 활성화하도록 PRCM 모듈에 요청 -> a module wake-up transition
마스터 모듈이 클락이 더 이상 필요없을 때 닫을 것을 요청 -> (마스터 모듈) in stanby mode


[Table 3-1 Master Module Standby Mode Settings]

0x0 Force-standby: 안의 동작과 관계없이, 데이터를 잃을 수 있다. (디버깅 목적)
0x1 No-standby: 클락을 활성화된 상태로 놔둔다. power적으로 효율적이진 않다. (디버깅 목적)
0x2 Smart-standby: 진행중인 상호교류가 있을 때만 standby 신호가 생기고 그렇지 않으면 잠든(idle) 상태 (실제 사용시)
0x3 Smart-standby wake-up-capable mode: 적당한 mwakeup output이 실행될 때만 연관이 있다. (실제 사용시)


[Table 3-2 Mater Module Standby Status]

0x0 모듈이 기능하고 있는 상태
0x1 모듈이 스탠바이 모드일 때


[Table 3-3 마스터 모듈 클락이 가능해지는 조건]

클락도메인이 준비되어 있어야 하고 (AND)
마스터 모듈 스탠바이 요청이 시작되지 않아야 한다. (OR)
마스터 모듈 wake-up 요청이 시작되야 한다. (OR)


* Slave idle protocol 자세히

PRCM모듈이 슬레이브 모듈의 상태를 조절
클락이 닫을 수 있을 때, PRCM모듈이 IDLE 요청으로 슬레이브 모듈에게 알린다.
슬레이브는 요청을 알아차리고 PRCM모듈은 모듈의 클락을 닫는다.
클락이 PRCM모듈에 의해서 닫히면, 슬레이브 모듈을 IDEL 상태

마스터 모듈로 부터 서비스 요청이 오거나, 슬레이브 모듈이 wake-up 이벤트를 받으면 슬레이브 모듈은 깨어나야 한다.
PRCM모듈은 슬레이브 모듈을 위한 클락을 가능하게 하고 IDLE 요청을 중단하면서 일어나라는 신호를 준다.


[Table 3-4 모듈 잠든(idle) 모드 세팅] (Table 3-1과 내용 같음, 스탠바이 상태를 잠든 상태로 바꾸면 된다.)

0x0 Force-idle
0x1 No-idle
0x2 Smart-idle
0x3 Smart-idle wake-up capable mode


[Table 3-5 슬레이브 모듈 idle 상태]

0x0 Funtional: 모든 클락이 활성화
0x1 In transition: 일어나거나 자는 상태로 변하는 것
0x2 Interface idle: 인터페이스 클락은 잔다. 부분적인 기능적인 클락이 사용되고 있을 때 계속 기능한다.
0x3 Full idle: 모두 잔다.


스마트 idle 상태일 때, 슬레이브 모델은 IDLE 요청을 인식한다. 인터페이스 클락과 기능적인 클락의 활동을 감안하여
예를 들어 모듈이 자고 있는 상태에도 기능적인 클락은 활동상태로 남아야 한다면 모듈은 오직 인터페이스 클락만 닫는 조건이라는 것을 고려해서
IDLE 요청을 알아차려야 한다. -> CLOCKACTIVITY setting


[Table 3-6 슬레이브 모듈 클락 활동성 세팅]
    인터페이스 클락   기능적인 클락
0x0     닫힘		닫힘
0x1	활성		닫힘
0x2	닫힘		활성
0x3	활성		활성


[Table 3-7 슬레이브 모듈 모드 세팅 in PRCM]

0x0 Disabled
PRCM모듈이 슬레이브 모듈로 IDLE 요청을 보낸다.
만약 슬레이브 모듈이 요청을 인식했다면 PRCM모듈은 모든 클락을 닫는다.
이 상태에서는 오직 wake-up이벤트에만 반응한다.
 
0x1 Auto
PRCM모듈은 오직 인터페이스 클락만 관리(기능적은 클락은 관리하지 않음)
IDLE 요청도 클락도메인 상호교류를 토대로 자동적으로 한다.
슬레이브 모듈이 잠드는 요청을 인식하면 PRCM모듈은 인터페이스 클락을 닫는다.

0x2 Enabled
PRCM모듈이 두가지 클락을 모두 관리
기능적인 클락은 언제나 활성화
슬레이브 모듈이 잠든는 요청을 인식하면 오직 인터페이스 클락만 닫는다.

0x3 Reserved
가능하지 않음


[Table 3-8 슬레이브 모듈 인터페이스 클락 가능한 조건]

클락도메인이 준비되어 있음 (AND)
슬레이브 잠든 상태가 0x0(fully functional) (OR)
슬레이브 잠든 상태가 0x1(in transition) (OR)
슬레이브 일어나는 요청 발생 (OR)


[Table 3-9 슬레이브 모듈 기능적인 클락 가능한 조건]

클락도메인이 준비되어 있음 (AND)
슬레이브 잠든 상태가 0x0 or 0x1 or 0x2(interface clock is idled) (OR)
슬레이브 일어나는 요청 발생 (OR)


* 모듈이 일어나는 요청

슬레이브 모듈은 인터럽트나 DMA 요청이 발생하면 일어나야 한다. (잠자다가)
깨어나는 능력이 있는 슬레이브 모듈은 깨어나는 요청을 PRCM모듈에게 보낸다.
PRCM모듈은 슬레이브 모듈의 클락을 활성화하고 슬레이브 모듈의 깨어나는 요청을 인식한다.
깨어나는 이벤트가 발생할 때 기능적인 클락이 요구되는 것: synchronous wake-up event
두가지 클락이 다 닫혔을 때 발생하는 깨어나는 이벤트: asynchronous wake-up event

모듈 레벨에서 클락 매니지먼트 상호작용을 PRCM모듈과 개별적인 모듈 사이에서 구성된다.
슬레이브 모듈과 PRCM모듈이 상호작용을 하다가 끝난다고 PRCM이 바로 슬레이브 모듈의 클락을 닫는 것은 아니다.
같은 클락을 아직 활동 중인 다른 모듈과 공유한다. 이 공유하는 클락은 모듈의 활동이 끝날 때까지 필요하다.
결과적으로 PRCM모듈은 클락도메인 레벨에서의 클락 매니지먼트도 제공한다. (같은 클락을 공유하는 모듈들이 클락 도메인)

 
