Chapter 24 1064 P
High-End Timer Transfer Unit (HTU) Module

이 장에서는 하이 엔드 타이머 전송 장치 (HTU) 모듈에 대해 설명합니다. 
HTU는 DMA (직접 메모리 액세스) 모듈과 유사하지만 NHET (하이 엔드 타이머) 데이터를 마이크로 컨트롤러 RAM으로 전송하거나 마이크로 컨트롤러 RAM에서 전송하는 데 특화되어 있습니다.

- 1065p
24.1 Overview 
HET 전송 유닛은 전용 직접 메모리 액세스 제어기(DMA)로서, NHET RAM 및 RAM 버퍼는 주 메모리 주소 범위에 있습니다. 이렇게하면 시간이 많이 걸리지 않습니다. CPU는 NHET RAM에 액세스하여 측정 데이터를 수집하거나 출력 파형을 생성하므로 CPU를 자유롭게 하여 다른 작업을 수행 할 수 있습니다.


24.1.1 Features 
1) NHET와 주 메모리간에 데이터를 독립적으로 전송합니다.
2) 이중 버퍼 구성을 지원하는 8 개의 이중 제어 패킷
3) NHET 연산 / 이벤트에 의해 생성 된 전송 요청
4) 유연한 버퍼 처리를위한 각 이중 제어 패킷에 대한 원 샷, 원형 및 자동 스위치 버퍼 전송 모드
5) 상수 및 post-increment 어드레싱 모드 
     - post-increment addressing : 먼저 데이터를 읽거나 저장한 후 어드레스를 증가하는 방식 
        ( http://blog.naver.com/luis8282/20077550617) 
6) 32 비트 또는 64 비트 트랜잭션
7) 프로그램 가능한 메모리 영역 보호 
8) 패리티 보호 제어 패킷 RAM
9) 광범위한 진단 기능

- 1066p
24.2 Module Operation
HTU는 NHET에 단단히 연결되어 있으며 다른 주변 장치 모듈에서 데이터를 전송하지 않습니다.
그것은 NHET 프로그램과 구성 가능한 제어 패킷에 의해 생성된 요청의 도움으로 전송을 시작합니다.
그림 24-1은 HTU의 시스템 블록 다이어그램과 데이터 전송을 위한 기본 경로를 보여줍니다.
SCR (Switched Central Resource)에 대한 강한 결합 및 전용 버스는 주변 장치 버스에서 전송되는 데이터의 양을 줄여 전체 시스템 성능을 향상 시킵니다. 
그러나 응용 프로그램이 NHET RAM에 직접 CPU 액세스 하는 방법을 사용하려는 경우에는 자유롭게 사용할 수 있습니다.

그림 24-2는 HTU 모듈의 보다 상세한 블록 다이어그램을 보여줍니다.
ㄴ용어정리  : 
   SCR : 중앙 자원 교환(?) 


-1067p
NHET RAM과 주 메모리 사이의 전송은 8 가지 다른 일반적인 NHET 요청에 의해 트리거 됩니다.
단순한 요청은 특정 경우에 사용되며 24.2.4.1 그림에서 보여줍니다. 
소스 및 목적지 어드레스를 저장하는 제어 패킷, 전송 카운트 및 다른 정보(Section 24.5)는 요청과 관련됩니다. 
FIFO는 읽기 및 쓰기 경로를 분리하고 서로 다른 읽기 및 쓰기 데이터 크기의 경우 데이터 패키징을 수행 할 수 있습니다.
응용 프로그램은 데이터가 전송되거나 전송되는 메모리 섹션을 지정할 수 있습니다.
이것은 메모리 보호 역할을합니다. 제어 패킷 RAM의 정보가 실수로 변경되어 HTU가 중요한 응용 프로그램 데이터를 덮어 쓸 수 없게 합니다. 
제어 패킷은 데이터 전송을위한 두 개의 버퍼를 지정할 수있는 이중 제어 패킷 (DCP)으로 구현됩니다.
이렇게하면 CPU가 하나의 버퍼로 작업 할 수 있고 새 데이터는 다른 버퍼로 전송됩니다.

컨트롤 패킷은 정의됩니다.
1) 소스 버퍼 또는 목적지 버퍼의 개시 주소
2) NHET 명령 주소 위치
3) 전송되어야하는 요소의 수
4) 버퍼 처리

특정 조건(예를 들어 capture, 조건비교)이 NHET 명령에 의해 감지되면 전송이 트리거됩니다.
NHET 명령은 이벤트에서 HTU에 대한 요청 라인이 트리거되도록 지정합니다.
DCP는 요청 라인에 고정 할당되어 있으며 해당 할당은 장치 데이터 시트에 있습니다. 요청이 트리거되면 프레임 전송이 시작됩니다. 프레임은 하나 이상의 요소를 포함 할 수 있습니다. 요소는 32 비트 또는 64 비트 데이터 word로 정의됩니다.

-1068p
24.2.1 Data Transfers between Main RAM and NHET RAM 
메인 RAM과 NHET RAM 간의 데이터 전송
24.2.1.1 Addressing Modes 어드레스 모드
제어 패킷의 어드레싱 모드는 CPU의 메인 RAM과 NHET RAM 사이에서 구별 될 필요가 있습니다.

- main RAM
각 이중 제어 패킷에 대한 main RAM의 어드레싱 모드는 레지스터 IHADDRCT에서 상수 또는 post-increment로 구성 될 수 있습니다.
1) 상수 어드레스 : 상수모드에서, HTU는 메인 RAM의 동일한 어드레스로 데이터를 읽고 씁니다.
2) Post-increment 어드레스 : HTU는 각 전송 후에 어드레스를 증가시킴으로써 메인 RAM으로부터 데이터를 읽고 씁니다.
   만약 32bit 전송이라면 자동적으로 4바이트가 증가하며, 64bit 전송이라면 8바이트가 증가합니다. 
   예를 들어 설명하면, 연속적인 프레임 요소는 연속적인 main RAM 버퍼에 전송된다.




- NHET RAM
DCP가 NHET RAM을 처리하는 방법은 초기 NHET 주소, 초기 요소 카운터 (IETCOUNT) 및 NHET 주소 지정 모드 (ADDMH)에 의해 결정됩니다. 메인 RAM과의 주된 차이점은 주소 지정 모드는 HET 주소가 프레임의 모든 첫 번째 요소에 대한 초기 HET 주소로 재설정된다는 것입니다. 
상수 주소 지정을 구현하려면 초기 요소 카운터를 1로 설정해야합니다. 
Post-increment 어드레스는 1이외의 값으로 프로그래밍 해야합니다. 

24.2.1.2 Single Buffer Implementation단일 버퍼 구현
단일 버퍼 구현에서, DCP는 메인 RAM의 단일 버퍼로부터 데이터를 전송하도록 설정 됩니다.
각 전송 요청으로 프로그래밍 된 요소 수를 전송하고 프로그래밍 된 수의 프레임 전송이 완료되면 버퍼 포인터가 시작 주소로 재설정됩니다.
HTU의 한 요청 라인에서 요청을 보여주고 할당 된 제어 패킷 상에서 동작하는 프레임은 요소 카운터에 의해 시각화 됩니다. 

Figure 24-4 의 다이어그램은 5개 요소의 프레임 전송을 나타냅니다. 

-1069p
응용 프로그램이 버퍼를 읽기 전에, 데이터를 액세스하는 동안 새 데이터가 버퍼를 덮어 쓰지 않도록 제어 패킷을 비활성화해야합니다.
t1 또는 t2에서 비활성화 된 제어 패킷에 관계없이 트리거 요청이 이미 수신되었으므로 마지막 프레임이 항상 완료됩니다. 응용 프로그램은 TIPF 플래그 및 NACP 비트를 통해 진행중인 전송을 결정할 수 있습니다.

One Shot Buffer Mode: TMBA 또는 TMBB가 원샷 버퍼 모드로 설정된 경우 버퍼 A 또는 버퍼 B의 모든 요소가 전송 된 후 데이터 스트림이 중지됩니다. 즉, 마지막 프레임이 버퍼 A 또는 B에서 전송되고 CFTCTA 또는 CFTCTB가 0으로 감소한 후 해당 DCP가 비활성화됩니다.

Circular Buffer Mode: TMBA 또는 TMBB가 순환 버퍼 모드로 설정된 경우 버퍼 A 또는 B의 모든 요소가 전송 된 후 버퍼 A 또는 B의 시작에서 데이터 스트림이 다시 계속됩니다. 순환 버퍼 모드의 타이밍 예제의 예는 IETCOUNT = 3 (초기 요소 전송 횟수), IFTCOUNT = 3 (초기 프레임 전송 횟수, SIZE = 0 (전송 크기 = 32 비트) 및 ADDFM = 0 (어드레싱 모드 주 메모리 = 사후 증가). 따라서 버퍼에는 총 9 개의 32 비트 값이 있습니다.
또한 IFADDRx = 10h라고 가정합니다. "U"는 초기화되지 않았 음을 의미합니다.

1070p
24.2.1.3 Dual Buffer Implementation 이중 버퍼 구현
전송 단위는 데이터 스트림 당 두 개의 버퍼 (HTU 요청 소스 당)의 사용을 지원하는 이중 제어 패킷 (DCP)을 제공합니다. 하나의 버퍼가 CPU 또는 DMA에 의해 판독되어야 한다면,
데이터 스트림은 다른 버퍼로 보내지고 첫 번째 버퍼는 고정됩니다. 프로그래밍 된 수의 프레임이 전송되었을 때 다른 버퍼로 자동 전환되도록 구성된 DCP 또는 CPENA 레지스터에 대한 쓰기 액세스로 다른 버퍼로 전환 할 수 있습니다. 버퍼를 고정하면 CPU 또는 DMA가 버퍼를 읽는 동안이 버퍼가 새 HET 데이터로 덮어 쓰지 않습니다.

그림 24-6은 HTU의 요청 소스 인 DCP 1과 DCP 2로 제어되는 두 개의 HET 명령어 1과 2의 타이밍 예를 보여줍니다. 생성 된 각 프레임에는 5 개의 요소 전송이 있습니다. 요구 소스 1은 2 개의 제어 패킷 1A 및 1B에 의해 제어되는 2 개의 RAM 버퍼를 갖습니다. 요구 소스 2는 2 개의 제어 패킷 2A 및 2B에 의해 제어되는 2 개의 RAM 버퍼를 갖습니다. 

-1071p
그림 24-6은 버퍼 1A가 고정되고 데이터 스트림 1이 버퍼 1B로 보내지지만 프레임이 완료된 후에 시간 t1에서의 스위치를 보여줍니다. 또한 2A가 동결되고 데이터 스트림 2가 버퍼 2B로 보내지는 시간 (t2 또는 t3)을 보여줍니다. 요청과 프레임 시작 (예 : 시간 t3) 사이에 전환이 발생하면 프레임은 새 제어 패킷에 의해 처리됩니다 (이전 제어 패킷이 요청 시간에 활성화 되었음에도 불구하고) HTU 요청과 요소 전송의 시작 사이의 지연은 HTU가 한 번에 하나의 전송만 처리 할 수 있다는 사실에서 기인합니다.

Auto Switch Buffer Mode
TMBA가 자동 전환 모드로 설정된 경우 버퍼 A의 모든 요소가 전송 된 후 데이터 스트림이 버퍼 B의 시작에서 계속됩니다. 즉, CPENA 레지스터에서 CP A가 비활성화되고 CP B는 자동으로 활성화되고 버퍼 B는 초기 주 메모리 주소와 초기 프레임 카운터를 사용하여 시작합니다. 동일한 원칙이 TMBB 및 버퍼 B에도 유효합니다.

-1072p
그림 24-7의 예는 IETCOUNT = 3 (초기 요소 전송 수), IFTCOUNT = 3 (초기 프레임 전송 수, SIZE = 0 (전송 크기 = 32 비트) 및 ADDFM = 0 (주소 지정 모드 주 메모리 = Post 따라서 버퍼 A와 B에는 총 9 개의 32 비트 값이 있습니다. 또한 IFADDRB = 10h 및 IFADDRA = 40h로 가정합니다. "U"는 초기화되지 않았음을 의미합니다.


24.2.1.4 General Control Packet Behavior 일반 제어 패킷 동작
선택한 모드로 정의 된 동작은 프레임 카운터 값이 1 인 마지막 프레임의 끝에서 수행됩니다
원샷 및 자동 전환 모드는 이때 CPENA 레지스터를 자동으로 업데이트합니다. 위에 나열된 세 가지 모드 모두에 대해 현재 버퍼의 끝에 도달하기 전에 CPENA에 기록하여 다른 버퍼로 전환 할 수 있습니다.
DCP x의 마지막 프레임 (프레임 카운터 = 1 포함)이 전송되는 동안 CPENA에 대한 쓰기 액세스가 발생하면 우선 순위는 표 24-1에 의해 정의됩니다.

-1073p
CPU가 주 메모리 조작을 원하지만 HTU가 주 메모리를 수정하는 것을 원하지 않는 경우가 있을 수 있습니다. 요청이 이미 활성화되었지만 응용 프로그램이 제어 패킷을 비활성화했을 때 프레임 전송이 아직 시작되지 않았을 수 있습니다. 그림 24-8의 타이밍 다이어그램은 이 시나리오를 보여줍니다.

DCPx가 비활성화되기 전에 전송 요청이 이미 수신되었으므로 HTU는 여전히 프레임 전송을 시작합니다. 응용 프로그램은 DCPx가 비활성화 된 시점과 프레임이 시작되기 전에 BUSYx 비트를 폴링하여 약속 있음 없음 정보를 읽습니다
그런 다음 모든 전송이 완료되었다고 생각하는 주 메모리 작업을 시작하지만 시간이 지나면 HTU가 뛰어난 프레임 전송을 시작하고 주 메모리를 손상시킵니다. 
이를 피하기 위해 응용 프로그램은 HTU와 주 메모리 간의 모든 트랜잭션을 비활성화하도록 VBUSHOLD 비트를 설정할 수 있습니다. 버스에서 미해결 트랜잭션이 보류 중인지 확인하기 위해 BUSBUSY 비트를 폴링해야합니다. HTU는 여전히 NHET에서 모든 전송 요청을 수신하지만 VBUSHOLD 비트가 설정되어있는 동안 주 메모리로 데이터를 전송하거나 주 메모리에서 데이터를 전송할 수 없습니다.

24.2.2 Arbitration of HTU Elements and Frames  HTU 요소와 프레임의 중재 
- 프레임은 서로 간섭하지 않습니다. 다른 프레임이 DCP y (및 x ≠ y)에서 실행되는 동안 DCP x에서 요청이 발생하면 현재 프레임이 새 프레임이 시작되기 전에 완료됩니다. 
- 둘 이상의 요청 행이 활성화 된 경우, 더 낮은 번호의 요청 행 (해당 NHET 명령의 요청 번호 필드에 지정됨)이 먼저 처리됩니다.  ( 우선순위를 두고 실행된다는 얘기 )

24.2.3 Conditions for Frame Transfer Interruption 프레임의 전송 중단 조건
프레임이 현재 DCP x에서 전송되고 아래에 나열된 이벤트 중 하나가 발생하면(1) 이벤트가 DCP x의 요소 카운터를 지우고 (2) DCP x에서 새 요소 전송을 중지합니다. (3) DCP x의 활성 중 비트 및 CPENA 레지스터에서 DCP x를 비활성화 한다. (4) DCP x 이외의 DCP는 영향을 받지 않습니다.
- DCP x의 손실된 오류 요청 (CORL 비트를 0으로 설정)
- DCP x의 패리티 오류 (패리티 검사가 활성화되고 COPE 비트가 0으로 설정 됨) 24.2.6 절을 참조하십시오.
-DCP x의 버스 오류.
-DCP x의 메모리 보호 오류 (메모리 보호가 활성화 된 상태). 24.2.5 절을 참조하십시오
- 해당 비트가 1이면 BUSY 비트 (DCP x에 속함)에 1을 씁니다. BUSY 비트가 0이면 효과가 없습니다.
-HTURES 비트 하나에 기록
메모리 보호 오류가 발생하면 보호 된 주소에 대한 액세스가 차단됩니다. 위반 전송을 야기한 요소가 시작되기 전에 프레임이 중지됩니다. 다른 모든 오류는 현재 요소 전송이 완료되도록 합니다. Request Lost 및 Bus Error의 경우, 프레임이 실제로 중지되기 전에 하나 이상의 요소 전송이 버스에서 진행됩니다. 따라서 사용중인 비트는 오류를 유발 한 요소 다음에 오는 요소 다음에 지워집니다.
버스 오류의 경우 오류의 원인이 된 요소 뒤에 오는 요소의 카운터가 ERRETC 레지스터 필드에 캡처됩니다.

- 1074p
NOTE:
프레임이 전송되는 동안 HTUEN 비트가 지워지면 HTU가 비활성화되기 전에 프레임이 완료됩니다.
24.2.4 HTU Overload and Request Lost Detection HTU 과부하 및 요청 분실 감지
다른 HTU 요청 소스의 수가 "높다"면, 요청 사이의 기간은 "짧습니다" 그리고 / 또는 초기 요소 카운터 값은 "큰"경우 HTU는 과부하 상황에 빠질 수 있습니다. 그림 24-9에서 "L"로 표시된 모든 요청은 다음 요청이 발생할 때 프레임이 완료되지 않았기 때문에 손실됩니다. "TU request (x)"행의 각 숫자는 관련 NHET 명령이 DCP x에서 요청을 생성하는 시간을 나타냅니다. 그림 24-9의 화살표는 연관된 프레임을 가리키고 있으며 요청에 비해 지연 될 수 있습니다.
지연은 현재 처리된 다른 프레임에 의해 발생합니다. 그림에서는 RLBECTRL 레지스터의 CORL 비트가 설정되어 DCP가 활성화 된 상태로 유지되고 DCP에서 요청 손실 오류가 발생한 후에도 데이터 스트림이 계속되도록합니다 (TU 요청 (2)의 경우 3-L 참조).


손실 된 요청은 RLOSTFL 레지스터와 함께 전달되며, 활성화 된 경우 요청 손실 인터럽트를 생성 할 수 있습니다.
CORL 비트가 설정되면 프레임이 완료되고 이 프레임에서 요청이 손실 된 경우에도 해당 DCP가 계속 사용됩니다.
이중 버퍼 모드에서 요청 손실 감지는 CP 스위치와 독립적으로 계속 작동합니다.

24.2.4.1 Requests and Quiet Requests 요청과 단순 요청
너무 많은 전송 요청을 생성하여 HTU에 과부하가 걸리고 데이터를 전혀 전송할 수 없으면 불일치 데이터가 전송 될 수 있습니다. 다음 예제는 그러한 시나리오를 설명합니다.
아래의 예에서, HTU는 세 가지 다른 지시의 데이터 필드에서 세 요소의 프레임을 읽습니다.
그림 24-10에서 L3 명령어는 시간 t2, t7 등에서 HTU 요청을 생성하고 해당 프레임 (t3에서)을 생성합니다. HTU로드로 인해 프레임이 지연됩니다. 그러나 그림 24-10에 표시된 것처럼 지연은 명령 L1의 데이터 필드가 다시 업데이트되기 전에 프레임이 완료되도록 합니다.
그러나 지연이 더 길면 (그림 24-11과 같이), 프레임은 NHET 루프 (LRP)로 떨어질 수 있으며, NHET은 L1, L2 및 L3 명령어의 데이터 필드를 업데이트합니다
이 경우 HTU는 그림과 같이 일치하지 않는 데이터를 읽을 수 있습니다. L1에서 (시간 t3에서) 잘못된 (new) 값이 판독되지만, L2 및 L3 (시간 t4 및 t5에서)에서 정확한 (old) 값이 판독됩니다.

-1075p
일관성있는 데이터를 보장하기 위해 NHET 지침은 전송을 시작하지는 않지만 일관성 검사를 위해 HTU에서만 사용하는 조용한 요청을 생성 할 수 있습니다. 단순 요청이 발생할 때 프레임이 마지막 요청 이후 완료되지 않았거나 시작되지 않은 경우 HTU는 요청 손실 오류를 신호합니다.
요청을 생성 할 수 있는 모든 지침은 대신 단순 요청을 생성하도록 구성 할 수 있습니다.
따라서 그림 24-10과 그림 24-11의 예에서 명령 L1은 단순 요청을 생성하고 명령 L3은 정상 요청을 생성하도록 구성되어야 합니다. 그림 24-11의 경우 RLOSTFL 레지스터의 해당 비트가 설정됩니다.
DCP x로 처리되는 명령 블록의 첫 번째 명령에 대한 단순 요청을 가능하게하고 이 블록의 마지막 명령에 대해서만 정상적인 요청을 가능하게 하는 것은 NHET 소프트웨어의 책임입니다.
단순 요청을 활성화하면 DCP x에 대한 적절한 요청 손실 감지가 가능해야 하므로 NHET 지침 모두에서 동일한 DCP x (reqnum = x)를 지정해야 합니다.
HET 명령어의 제어 필드는 2 비트 필드를 제공하여 다음과 같은 가능성 중 하나를 구성합니다 (표 24-2 참조). 프로그램 필드의 3 비트 필드는 요청에 의해 트리거 될 8 개의 이중 제어 패킷을 선택합니다.

-1076p
매우 가벼운 HTU 부하이지만 높은 신호 요구 사항 (예 : 고주파)의 경우에는 단순 요청을 사용하여 제어 패킷에 의해 읽혀지는 데이터가 안전한 기간을 정의 할 수 있습니다. 다음 HET 코드는 상승 에지 (핀 CC6에서)와 L2-WCAP 데이터 필드 (핀 CC6에서)의 하강 에지 후에 카운터 타임 스탬프를 L1-WCAP 데이터 필드에 캡처합니다.
HTU 프레임에는 두 가지 요소가 있습니다. 첫 번째는 상승 에지 r (n)의 타임 스탬프를 제공하고 두 번째는 이전 하강 에지 f (n-1)의 타임 스탬프를 제공합니다.
위의 코드를 사용하면 그림 24-12에 표시된 시간에 요청 (R)과 단순 요청 (QR)이 발생하고 손실 된 요청은 RL로 표시된 시간 동안 프레임이 액세스 할 때만 신호가 보내집니다.
따라서 프레임 요소로 [22, 21]을 읽는 것은 정확합니다. 신호 주파수가 증가하면 잘못된 쌍 [22,24]을 읽을 수 있지만 적어도 e2가 RL 기간에 속하기 때문에 요청 손실 오류로 신호를 보냅니다.
24.2.5 Memory Protection 메모리 보호
이 기능을 사용하면 중요한 응용 프로그램 데이터가 의도하지 않게 HTU에 의해 조작되는 것을 방지하기 위해 메모리의 특정 영역에 대한 액세스를 제한 할 수 있습니다. HTU 메모리 보호 기능이 비활성화 된 경우 예외없이 HTU가 4GB의 전체 주소 범위에 액세스 할 수 있습니다.
시작 및 끝 주소를 구성 할 수 있는 두 개의 메모리 영역이 있습니다. 메모리 보호 기능을 사용하면 정의 된 영역 내의 HTU에 의한 읽기 및 쓰기 액세스가 허용됩니다. 지역 외부의 액세스에는 두 가지 모드 중 하나를 구성 할 수 있습니다.
- HTU가 수행하는 모든 액세스는 금지되어 있으며 ESM 모듈에 신호가 전송됩니다. 
쓰기 액세스가 차단됩니다.
- 읽기 액세스는 허용되지만 쓰기 액세스는 차단되어 ESM 모듈에 신호됩니다.
한 영역 만 사용하려면 REG01ENA가 0이어야합니다. ACCR01, INTENA01 비트, MP1S, MP1E의 레지스터 설정은 무시됩니다.

두 영역을 모두 사용하려면 아래 규칙을 따라야합니다.
1. 메모리 맵핑 된 영역 0은 메모리 맵핑 된 영역 1과 같이 하위 메모리 영역을 포함합니다.
2. REG01ENA는 하나이며 REG0ENA는 0입니다.
3. ACCR01이 원하는 액세스 유형으로 설정되면 ACCR0은 무시됩니다.
4. INTENA01이 원하는 동작으로 설정되면 INTENA0은 무시됩니다.

-1077p
DCP x의 요소 전송에서 메모리 보호 오류가 발생하면 다음을 수행합니다.
1. DCP x의 요소 카운터가 지워집니다.
2. DCP x의 모든 새 요소 전송이 중지됩니다.
3. DCP x의 활성 중 비트가 해제됩니다.
4. DCP x는 CPENA 레지스터에서 비활성화됩니다. DCP x 이외의 DCP는 영향을받지 않습니다.
5. FT 플래그가 설정됩니다.
6. 오류가 ESM 모듈에 전달됩니다.

24.2.6 Control Packet RAM Parity Checking 제어패킷의 RAM 패리티 검사
HTU 모듈은 DCP (Double Control Packet) RAM의 패리티 오류를 감지 할 수 있습니다. DCP RAM 패리티 검사는 바이트 당 하나의 패리티 비트를 사용하여 구현됩니다. 짝수 또는 홀수 패리티 검사는 시스템 모듈의 DEVCR1 레지스터에서 선택할 수 있으며 PCR 레지스터의 4 비트 키로 활성화 / 비활성화 할 수 있습니다.
DCP RAM에 대한 읽기 액세스 중에 RAM에서 읽은 데이터를 기반으로 패리티가 계산되고 패리티 비트에 저장된 양호한 패리티 값과 비교됩니다. 패리티 검사는 HTU 또는 다른 마스터 (예 : CPU)가 DCP RAM에 대한 읽기 액세스를 할 때 수행됩니다. 초기 DCP 또는 현재 DCP의 RAM 섹션 내의 읽기 액세스는 한 번에 DCP의 모든 16 바이트를 검사합니다 (DCP 메모리
지도). 예를 들어, DCP RAM 주소 0에 대해 바이트 읽기 액세스가 발생하지만 바이트 주소 Ch에 패리티 오류가 발생하면 패리티 오류가 발생하고 캡처 된 패리티 주소는 0이 아닌 Ch가됩니다.
오류가 발생한 바이트의 주소는 PAR 레지스터에서 읽을 수 있습니다. 연속적인 DCP RAM 읽기 액세스가 다중 패리티 오류를 생성하면 첫 번째로 감지 된 오류의 주소만 캡처되고 PAR 레지스터는 응용 프로그램에서 읽을 때까지 후속 오류로 업데이트되지 않습니다.
16 바이트 단어의 여러 오류가 감지되면 가장 낮은 바이트의 주소만 캡처됩니다.

응용 프로그램은 패리티 오류가 감지 될 때 전송을 중지할지 또는 데이터 전송을 계속할지 여부를 결정할 수 있습니다. COPE (패리티 오류 계속) 비트가 0이고 패리티 검사가 활성화 된 경우 HTU는 프레임을 시작하지 않고 해당 DCP가 CPENA 레지스터에서 자동으로 비활성화됩니다. HTU가 아닌 마스터 (예 : CPU)가 DCP x의 RAM 섹션을 읽고 이 읽기 액세스 중에 패리티 오류가 감지되면 패리티 검사가 활성화되고 COPE 비트가 0 인 동안 DCP x는 CPENA 레지스터에서 자동으로 비활성화됩니다. 이 읽기 액세스 중에 DCP x의 프레임이 진행 중이면 DCP x의 요소 카운터가 지워지고 DCP x의 모든 새 요소 전송이 중지되고 DCP x의 활성 중 비트가 지워집니다.
COPE를 1로 설정하고 패리티 검사를 활성화하면 패리티 검사가 여전히 수행되지만 이 DCP에 대해 패리티 오류가 감지 된 후 활성 DCP의 데이터 전송이 계속됩니다. 따라서 패리티 오류가 있는 DCP는 비활성화되거나 프레임이 중지되지 않습니다.
DCP가 활성화 된 후 (BIM = 0을 사용하는 CPENA 사용) 첫 번째 프레임이 시작될 때 HTU는 현재 DCP 정보가 필요 없으므로 초기 DCP에서만 패리티 검사를 수행합니다. 이후 프레임의 경우 HTU는 두 정보가 모두 필요하기 때문에 초기 DCP와 현재 DCP 모두에 대해 패리티 검사를 수행합니다.
패리티 오류 감지에서 오류는 ESM 모듈에도 전달됩니다.

-1078p
24.2.6.1 Parity Bit Mapping and Testing 패리티 비트 매핑과 테스트
패리티 검사 메커니즘을 테스트하기 위해, 수동 오류 삽입을 허용하기 위해 패리티 RAM을 액세스 가능하게 만들 수 있습니다. TEST 비트가 설정되면 패리티 비트는 FF4E 0200h 번지에 매핑됩니다.
테스트 모드 (패리티 RAM에 액세스 할 수 있음) 일 때, 패리티 RAM에서 읽을 때 패리티 검사는 수행되지 않지만 DCP RAM에 대한 읽기 액세스에 대해서는 패리티 검사가 여전히 수행됩니다.
표 24-3 및 표 24-4는 DCP RAM 바이트의 해당 패리티 비트가 메모리에 매핑되는 방법을 보여줍니다.

DCP RAM의 각 바이트는 DCP 패리티 RAM에 자체 패리티 비트가 있습니다. P0는 바이트 0에 대한 패리티 비트이고, P1은 바이트 1에 대한 패리티 비트이며, 계속 계속됩니다.

24.2.6.2 Initializing Parity Bits 패리티 비트 초기화 
( DCP 메모리와 패리티 비트를 초기화하는 방법 ) 
장치의 전원이 켜지면 패리티 비트를 포함한 DCP RAM 내용을 보장 할 수 없습니다. 패리티 오류를 방지하려면 DCP RAM을 읽을 때 RAM을 먼저 초기화해야 합니다. 이것은 알려진 값을 소프트웨어로 RAM에 쓰면 간단히 수행 할 수 있으며 해당 패리티 비트는 자동으로 계산됩니다.
DCP 메모리와 패리티 비트를 초기화 할 수 있는 또 다른 방법은 HTU 외부의 온칩 모듈인 시스템 모듈을 사용하는 것입니다. 이 모듈은 HTU DCP RAM을 포함하여 마이크로 컨트롤러에 있는 모든 RAM의 자동 초기화를 시작할 수 있습니다. 이 함수는 완전한 DCP RAM을 "0"으로 초기화합니다. 시스템 모듈에 의해 활성화됩니다. 짝수 / 홀수 패리티 선택에 따라 모든 패리티 비트가 그에 따라 계산됩니다. 자동 DCP RAM 초기화 중에는 HTUEN 비트를 지워야하고 패리티 기능을 활성화 해야합니다 (PARITY_ENA에 의해). 시스템 모듈에 의해 초기화가 트리거 될 때 HTUEN이 하나 인 경우, 초기화는 수행되지 않고 HTU 조작은 영향을 받지 않습니다. 초기화 중에 HTUEN에 기록 된 것이면 HTUEN 비트가 설정되지만 초기화가 완료되기 전에 HTU는 활성화되지 않습니다.



-1079p
24.3 Use Cases
24.3.1 Example: Single Element Transfer with One Trigger Request 
 하나의 트리거 요청으로 단일 요소 전송
24.3.2 Example: Multiple Element Transfer with One Trigger Request
하나의 트리거 요청으로 다중 요소 전송
24.3.3 Example: 64-Bit-Transfer of Control Field and Data Fields
제어 필드 및 데이터 필드의 64 비트 전송

-1082p
24.4 HTU Control Registers
