* Device Tree 란 무엇인가 ?

FPGA 와 유사하게 Description Language 개념이 적용된 것임
좀 더 구체적으로 HW(SoC, Board) 에 대한 정보를 기술함
이와 대비되는 방식으로 기존에 사용하던
Platform Device 기반의 Board 기술 방식이 존재함
(이 방식은 기존에 사용하던 방식으로 C 로 기술하던 방식임)



* 기존 방식의 문제점

1. SoC 혹은 Board 별로 독자적 코드를 구현해야함
2. 같은 SoC 에서 파생된 보드 간에 상호 연관성이 있지만
   이를 전혀 고려하지 않고 별도로 구현함
3. 2 번의 문제로 코드의 복잡도가 증가하고 코드 크기가 증가함
   arch/arm/mach-{TARGET}/board-*.c 파일이 매우 복잡해짐
4. 보드 구성이 바뀌더라도 Kernel Code 를 수정하지 않고
   동작할 수 있는 방식의 필요성 인식
5. Device Tree 는 기존에 다른쪽(CPU)에서 사용하던 방식으로 ARM 도 채택!



* Device Tree 에서 장치 표현 방식

1. Device 는 노드로 표현하며(ex: node@0),
   각각의 노드는 다양한 속성 정보를 갖는다.
   각각의 Device 는 서로 다른 속성 정보(ex: address, interrupt 등)을 가짐
   특히 compatible 속성은 Device Driver 와 연결되는 부분으로
   Device Driver Code 에서 관련 compatible string 을 검색해보면
   연결된 platform driver 를 찾을 수 있다.

2. node@ 뒤에 붙는 숫자는 unit address 로
   Device 에 접근하기 위해 사용되는 1 차 주소이고
   Node 내의 reg 속성에 나열되어 있는 정보에 해당한다.
   unit address 는 UART0, UART1 과 같이 동일한 장치가 여러개 있을 경우
   각각의 장치를 정확하게 판별하기 위해 사용한다.

3. 노드내에 또 다른 노드가 올 수 있다.
   Device Controller 와 연결된 Slave 인 Device 라고 생각하면 되겠다.

4. 노드는 앞 부분에 별칭(alias)을 붙일 수 있으며
   다른 노드에서 이 별칭을 활용하여 해당 노드를 참조하는데
   이때 & 기호를 사용한다(ex: &node3)

5. 실제로 매우 다양한 장치가 있어서
   독자적 Device 를 표현하기 위해서 bindings 문서를 잘 정리해야함
   실제 AM5728 에서 제공하는 dts 파일을 살펴보면 도움이 많이됨

추후 AM5728 Kernel 디렉토리에서 arch/arm/boot/dts/am57xx-evm-reva3.dts
를 살펴보면 Device Tree 를 이해하는데 보다 도움이 될 것이다.



* Device Tree 의 전체 구조

1. 확장자가 dtsi 인 파일은 SoC 를 표현하며 dts 는 하위 보드를 표현한다.

2. 계층 구조를 유지하기 위해 하위 보드는 상위 보드
   혹은 SoC 의 dts 를 상속받을 수 있으며
   include 문(혹은 C style 의 #include 도 가능)을 사용하여
   상위 보드 혹은 SoC 를 위한 dts 파일을 포함시킬 수 있다.
   (dts 파일 중간에서 포함시키는 것도 가능함)

3. 하위 보드에서 정의한 내용 중,
   상위 보드의 내용과 중복되는 내용은
   하위 보드에서 정의한 내용이 최종적으로 반영되며
   중복되지 않는 내용은 새로 추가된다.
   *.dts 를 살펴보면 &node{} 로 된 부분이 있는데
   앞서 정의한 dts 를 overriding 하는 것이다.

4. SoC 구조를 보면 CPU, Memory, System Bus, Interconnect 들로
   구성되어 있는데 이것들이 모두 node 라고 보면 되겠다.
   OCP 는 On Chip Peripheral 을 의미하며
   각종 Device Controller 를 이 부분에 나열하면 된다.

5. 각각의 node 는 다양한 속성(ex: register, interrupt)가 있으므로
   이를 적절히 표현해 주어야하며 node 간에는
   상호 연관성(ex: interrupt, clock) 이 있을 수 있으니,
   역시 이를 잘 표현(&node 활용)해 주어야 한다.

dtsi 파일(SoC) 와 dts(Board) 가 하나로 통합되어 dtb 가 만들어짐
dtsi 파일은 arch/arm/boot/dts/am57xx-evm-common.dtsi 를 살펴보도록 한다.

그리고 실제 Device Tree 로 표현된 Board Description 은
Kernel Code 에서 참조할 수 있어야하므로
아래의 파일에서 이러한 부분들을 볼 수 있다.
arch/arm/mach-omap2/board-generic.c 를 참고하면 도움이 된다.
compatible 속성과 관련된 부분이 compat 이라는 부분이라고 된 부분들임

arch/arm/boot/dts/am57xx-beagle-x15-common.dtsi 에서
i2c 를 찾아보면 node 표현을 볼 수 있다.
또한 i2c controller node 를 표현한것으로
compatible = "ti,tps659038" 속성을 갖고 있음을 볼 수 있다.
여기서 tps659038 이라는 반도체 소자는 차량용 전원 관리 소자에 해당한다.
실제 AM5728 Datasheet 와 회로도를 살펴보면
tps65903 과 기타 관련 소자들이 연결되어 있는 것을 볼 수 있다.
해당 파일에서 tps659038-pmic 같은것도 보인다.
회로도에 보면 pmic 가 TPS6590376ZWSR 에 있는 것을 볼 수 있다.
또한 여기에는 스위칭 레귤레이터가 있어서 SMPS 를 볼 수 있다.
i2c1 에 보면 smps 들이 있고 7 번, 9 번은
사용하지 않는다고 디바이스 트리에 표현되어 있다.
그 외에 LDO 리니어 레귤레이터들이 있고 rtc, pwr_button,
gpio, usb 등이 여기에 물려 있는것을 볼 수 있다.

i2c Slave Device 는 반드시 Slave address 속성을 지정해줘야 하는데
이것을 reg = <주소> 속성을 통해서 지정할 수 있다.
실질적으로 FW 프로그래밍시에도 I2C Slave 장치와의 통신에서도 0x58 을 사용한다.
그리고 drivers/i2c/busses/*.c 파일을 보면
Platform Driver 를 연결해주는 것에 해당하는 compatible 속성을 볼 수 있다.



또한 Interrupt 도 표현해줘야 한다.
arch/arm/boot/dts/dra7.dtsi 에 보면 gic 라는 interrupt-controller 가 보인다.
Interrupt Controller 는 반드시 자신이 인터럽트 제어기임을
알리기 위해 interrupt-controller; 문을 선언해 주어야 한다.
Interrupt 를 사용하는 장치에서 자신이 사용하는
Interrupt Controller 가 어떤 장치인지 기술해줘야 한다.
해당 파일에 보면 interrupt-parent = <&gic> 를 통해
gic 를 인터럽트 제어기로 사용하는 장치가 많다.
또한 interrupt 에 사용할 pin 번호를 지정해 준다.
이것은 interrupts = <숫자> 로 표현한다.
마지막으로 Driver Code 에서 Interrupt 를 등록해야 한다.
drivers/net/wireless/ti/wlcore/sdio.c 에 241 번 라인을 보면
irq_of_parse_and_map() 을 통해 반환값으로 Interrupt pin 번호를 얻어온다.



다음으로 Clock 부분을 살펴보자!
TRM 문서를 통해 Clock 이 어떻게 구동되는지 파악할 필요가 있다.
Device Tree 에서 Clock 은 아래와 같이 표현한다.
대표적으로 arch/arm/boot/dts/dra7xx-clocks.dtsi 를 살펴보면 됨
추가적으로 arch/arm/boot/dts/dra7.dtsi 도 살펴볼 필요가 있음

1. SoC 내의 모든 Clock 을 열거하며 주파수는 필수적이다.
2. 각각의 Device 에서 필요한 clock 을 clocks = <&cpuclk> 와 같이 참조한다.
3. 마찬가지로 Device Driver 단에서 이를 처리해주는 SW 가 필요하다.



Pin Mux 부분을 살펴보도록 하자!
Device Tree 에서 Pin Control 을 위해서 2 가지 절차가 필요하다.

1. 사용하려면 pin 의 목록을 정의한다(ex: I2C, UART, DMA, CAN 등등)
   Device(GPIO, I2C, DMA, CAN 등등)를 기준으로 pin 을 정의함
2. 1 번에서 정의한 pin 을 실제 Device 와 결합함
   pinctrl-<번호> 에는 pin control 목록을 적는다(ex: &can0_pins_a)
   그리고 pinctrl-names 에 pin control 이름을 부여한다.
   참고로 이름이 "defaults" 일 경우 probe 하면 자동으로 pin control 요청을 하게됨
3. 역시 마찬가지로 Device Driver 에서 pin control 을 요청하여
   실제 해당 pin 을 동작하게 만들어준다.

실제 AM5728 에 있는 led 를 고려해보자!
arch/arm/boot/dts/omap5-board-common.dtsi
arch/arm/boot/dts/omap5-cm-t54.dts
위의 두 부분을 보면 pinctrl 과 관련하여 LED 를 제어하는 부분이 있음을 볼 수 있다.
Pin Mux 를 하게되면 각각의 Device 에서 이를 사용하기 위해
결합(pinctrl-0, pinctrl-names) 와 같이 결합하는 부분을 볼 수도 있다.

arch/arm/boot/dts/omap5-board-common.dtsi 을 살펴보면 pinctrl-single,pins 속성도 보인다.
이와 같은것은 TI Chip 의 특성과 관련된 부분으로
drivers/pinctrl/pinctrl-single.c 에서 볼 수 있다.
