이 참조 메뉴얼은 FreeRTOS V9.0.0 을 위한 정보를 제공하기 위해 존재한다.
http://www.FreeRTOS.org 에서 정기적으로 updates, FreeRTOS Tutorial Books, 그리고 추가 온라인 문서를 검사하라.

이 문서는 무료로 제공된다.
그 대가로 http://www.FreeRTOS.org/contact 에서 business contact email 을 통해
의견, 주석 및 수정 사항을 제공할 것을 요청한다.
감사합니다.



The FreeRTOS Reference Manual

Chapter 1. About This Manual

1.1. Scope

이 문서는 주요 FreeRTOS API 및 FreeRTOS Kernel 구성 옵션 모두에 대한 기술 정보를 제공한다.
독자는 이미 Multi-Tasking Applications 작성의 개념과
Real-Time Kernel 이 제공하는 기본 개념에 익숙하다고 가정한다.
(실제로 수업 시간에도 이 부분에 상당한 시간을 할애한만큼 기억해주셈)
이 기본 개념에 익숙하지 않은 독자는 훨씬 더 설명하기 쉽고 실용적인 자습서 스타일의 문서인
"Using the FreeRTOS Real Time Kernel - A Practical Guide" 라는 책을 읽는 것이 좋다.
이 책은 http://www.FreeRTOS.org/Documentation 에서 얻을 수 있다.



The Order in Which Functions Appear in This Manual

이 문서에서 API 함수는 Task 및 Scheduler 관련 함수, Queue 관련 함수,
Semaphore 관련 함수, Software Timer 관련 함수, 그리고 Event Group 관련 함수, 총 5 개로 나뉜다.
각 Group 은 자체 챕터에 설명되어 있으며 각 Chapter 에서 API 함수가 사전 순으로 나열된다.
그러나 각 API 함수의 이름 앞에는 함수의 반환 형식을 지정하는 문자가 하나 이상 접두사로 붙어 있으며
각 장의 API 함수의 사전순 정렬은 함수 반환 형식 접두사를 고려하지 않고 적어놨다.
부록 1 : 접두어에 대해 자세히 설명한다.

예를 들어, FreeRTOS 태스크를 작성하는데 사용되는 API 함수를 고려해보자.
그 이름은 xTaskCreate() 이다. 'x' 접두사는 xTaskCreate() 가 비표준 유형을 반환하도록 지정한다. 
보조 'Task' 접두어는 함수가 태스크 관련 함수임을 지정하며
태스크 및 스케줄러 관련 함수가 포함된 장에서 다뤄진다.
'x' 는 사전순 정렬에서 고려되지 않으며
xTaskCreate() 는 TaskCreate() 처럼 Task 및 Scheduler 챕터에서 다뤄진다.



API Usage Restrictions

FreeRTOS API를 사용할 때 다음 규칙이 적용된다.

1. "FromISR" 에서 끝나지 않는 API 함수는 인터럽트 서비스 루틴(ISR) 에서 사용되어서는 안된다. 
    일부 FreeRTOS 는 "FromISR" 로 끝나는 API 함수조차도 configMAX_SYSCALL_INTERRUPT_PRIORITY 
    (또는 포팅 결과에 따라 configMAX_API_CALL_INTERRUPT_PRIORITY) 커널에 의해 설정된 우선 순위보다 
    (하드웨어) 우선 순위가 높은 인터럽트 서비스 루틴에서 사용할 수 없는 추가 제한 사항을 만든다.
    이와 관련한 구성 상수는 이 문서의 7.1 절에 설명되어 있다.
    두 번째 제한은 configMAX_SYSCALL_INTERRUPT_PRIORITY 에 의해 설정된 인터럽트보다
    우선 순위가 높은 인터럽트의 타이밍, 결정 및 대기 시간이 FreeRTOS의 영향을받지 않도록하는 것이다.

*  대체 API 는 더 이상 권장되지 않으므로 포함되지 않는다.
   공동 루틴은 응용 프로그램의 작은 하위 집합에만 유용하기 때문에 공동 루틴 API 도 생략한다.

2. 스케줄러가 일시 중단된 동안 Context Switch 를 유발할 수 있는 API 기능을 호출해서는 안된다.
3. 잠재적으로 Context Switch 를 유발할 수 있는 API 함수는 중요 섹션 내에서 호출되어서는 안된다.



Chapter 2. Task and Scheduler API

2.1. portSWITCH_TO_USER_MODE()

#include “FreeRTOS.h”
#include “task.h”

void portSWITCH_TO_USER_MODE( void );

Listing 1. portSWITCH_TO_USER_MODE() macro 프로토타입



Summary

이 기능은 고급 사용자를 대상으로하며 FreeRTOS MPU(메모리 보호 장치를 사용하는 FreeRTOS) 에만 관련이 있다.

MPU 제한 작업은 xTaskCreateRestricted() 를 사용하여 만든다.
xTaskCreateRestricted() 에 제공되는 매개 변수는
생성되는 작업이 사용자 (권한없는) 모드 작업인지  감독자 (권한있는) 모드 작업인지 지정한다.
Supervisor Mode Task 는 portSWITCH_TO_USER_MODE() 를 호출하여
Supervisor Mode Task 를 User Mode Task 로 변환 할 수 있다.

Parameters

없음.

Return Values

없음.

Note

Task 가 User Mode 에서 Supervisor mode Task 로 자체 변환할 수 있게 해주는
portSWITCH_TO_USER_MODE() 와 동등한 호환성은 없다.



2.2. vTaskAllocateMPURegions()

#include “FreeRTOS.h”
#include “task.h”

void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions );

Listing 2. vTaskAllocateMPURegions() function 프로토타입


Summary

MPU 제한 작업에 사용할 메모리 보호 장치(MPU) 영역 집합을 정의하라.

이 기능은 고급 사용자를 대상으로하며 FreeRTOS MPU(메모리 보호 장치를 사용하는 FreeRTOS) 에만 관련이 있다.

태스크가 xTaskCreateRestricted() 함수를 사용하여 생성될 때
MPU 제어 메모리 영역은 MPU 제한 Task 에 할당 될 수 있다.
그런 다음 vTaskAllocateMPURegions() 함수를 사용하여 런타임에 재정의하거나 다시 할당할 수 있다.

Parameters

- xTaskToModify
제한된 작업의 핸들이 수정된다(xRegions 매개 변수로 정의된 메모리 영역에 대한 접근이 제공되는 Task).
Task 의 핸들은 xTaskCreateRestricted() API 함수의 pxCreatedTask 매개 변수를 사용하여 가져온다.
Task 는 유효한 Task Handle 대신에 NULL 을 전달하여 자체 메모리 영역 접근 정의를 수정할 수 있다.

- xRegions
MemoryRegion_t 구조체의 배열이다.
배열의 위치 수는 portNUM_CONFIGURABLE_REGIONS 상수에 의해 정의된다.
Cortex-M3 에서 NUM_CONFIGURABLE_REGIONS 는 3 으로 정의된다.

배열의 각 MemoryRegion_t 구조체는 xTaskToModify 매개 변수가
참조하는 작업에서 사용할 단일 MPU 메모리 영역을 정의한다.

Notes

MPU 메모리 영역은 Listing 3 의 MemoryRegion_t 구조체를 사용하여 정의된다.

typedef struct xMEMORY_REGION
{
	void *pvBaseAddress;
	unsigned long ulLengthInBytes;
	unsigned long ulParameters;
} MemoryRegion_t;

Listing 3. xTaskCreateRestricted() 가 사용하는 자료 구조

pvBaseAddress 및 ulLengthInBytes 멤버는 메모리 영역의 시작과 메모리 영역의 길이로 각각 설명된다.
이들은 MPU 에 의해 부과된 크기 및 정렬 제한을 준수해야한다.
특히 각 영역의 크기와 정렬은 둘 다 동일한 2 의 멱승으로 같아야한다.

ulParameters는 태스크가 정의되는 메모리 영역에 접근하는 방법을 정의하며
아래 값중 비트 OR 을 취할 수 있다.

* portMPU_REGION_READ_WRITE
* portMPU_REGION_PRIVILEGED_READ_ONLY
* portMPU_REGION_READ_ONLY
* portMPU_REGION_PRIVILEGED_READ_WRITE
* portMPU_REGION_CACHEABLE_BUFFERABLE
* portMPU_REGION_EXECUTE_NEVER   



Example

/ * Task 가 읽고 쓰는 배열을 정의하라.
    크기와 정렬이 MPU 영역에서 적합한지 확인하라(GCC Syntax 사용에 유의하라) */
static unsigned char ucOneKByte [1024] __attribute __ ((align (1024))));

/ * ucOneKByte 배열의 시작 부분에서 시작하는 1024 byte 에 대한 읽기 / 쓰기 접근을 허용하는
    MPU 영역을 구성하는 MemoryRegion_t 구조체의 배열을 정의한다.
    최대 3 개의 정의 가능 영역 중 나머지 2 개는 사용되지 않으므로 0 으로 설정한다. * /
정적 const MemoryRegion_t xAltRegions [포트 NUM_CONFIGURABLE_REGIONS] =
{
	/ * 기본 주소 길이 매개 변수 * /
	{ucOneKByte, 1024, portMPU_REGION_READ_WRITE},
	{0, 0, 0},
	{0, 0, 0}
};

void vATask (void * pvParameters)
{
/* 이 Task 는 xTaskCreateRestricted() 를 사용하여
   최대 3 개의 MPU 제어 메모리 영역에 접근할 수 있다.
   어떤 시점에서 이러한 MPU 영역은 위에 정의된
   xAltRegions const 구조에 정의된 영역으로 대체해야 한다.
   이를 위해 vTaskAllocateMPURegions() 호출을 사용하라.
   변경 작업이 호출 작업에 적용되어야 함을 나타내기 위해 NULL 이 작업 핸들로 사용된다. */

	vTaskAllocateMPURegions (NULL, xAltRegions);
/ * 이제 Task 는 계속 기능을 수행할 수 있지만 이 시점부터는 스택 및 ucOneKByte 배열에만 접근할 수 있다
    (다른 정적으로 정의되거나 공유된 영역이 다른 곳에서 선언되지 않은 경우). * /
}

Listing 4 vTaskAllocateMPURegions() 의 사용 예



2.3. xTaskAbortDelay()

#include “FreeRTOS.h”
#include “task.h”
BaseType_t xTaskAbortDelay( TaskHandle_t xTask );

Listing 5. xTaskAbortDelay() function 프로토타입



Summary

제한 시간 매개 변수가 포함 된 API 함수를 호출하면 호출하는 Task 가 차단됨 상태가 될 수 있다. 
차단됨 상태에있는 작업은 제한 시간이 경과하기를 기다리거나
이벤트가 발생할 때까지 기다린 후 작업이 자동으로 차단됨 상태를 떠나 준비됨 상태가된다.
이 동작에 대한 많은 예가 있으며 그 중 두 가지는 다음과 같다.

Task 가 vTaskDelay() 를 호출하면 함수의 매개 변수로 지정된 시간이 경과할 때까지 Blocked 상태가된다.
이 시간이 지나면 Task 는 자동으로 Blocked 상태에서 Ready 상태가된다.

Task 알림 값이 0 일 때 ulTaskNotifyTake() 를 호출하면 알림을 받거나
함수 매개 변수 중 하나에 의해 지정된 시간 제한이 경과 할 때까지 차단 상태가된다.
이 시간이 지나면 작업은 자동으로 차단됨 상태를 벗어나 준비 상태가된다.

xTaskAbortDelay() 는 작업이 대기중인 이벤트가 발생하지 않았고 작업이 Blocked 상태로 들어갔을 때 
지정된 시간 제한이 경과하지 않은 경우에도 작업을 차단됨 상태에서 준비 됨 상태로 이동한다.

작업이 Blocked (차단됨) 상태에 있으면 스케줄러에서 사용할 수 없으며 처리 시간을 소비하지 않는다.

Parameters

xTask
Blocked 상태에서 벗어날 Task 의 Handle.

작업의 Handle 을 얻으려면 xTaskCreate() 를 사용하여 작업을 만들고
pxCreatedTask 매개 변수를 사용하거나 xTaskCreateStatic() 을 사용하여 작업을 만들고
반환 된 값을 저장하거나 xTaskGetHandle() 을 호출하여 작업의 이름을 사용한다.

Returned value

xTask 가 참조하는 Task 가 차단됨 상태에서 제거 된 경우 pdPASS 가 반환된다.
xTask가 참조하는 작업이 Blocked 상태가 아니기 때문에
Blocked 상태에서 제거되지 않은 경우 pdFAIL 이 반환된다.

Note

xTaskAbortDelay() 를 사용하려면 INCLUDE_xTaskAbortDelay 를 FreeRTOSConfig.h 에서 1 로 설정해야한다.



Example

void vAFunction (TaskHandle_t xTask)
{
	/* xTask 에 의해 참조된 Task 가 Block 되어
	   이 함수를 호출하는 Task 가 결코 없을 것이라 결정하고 기다린다.
	   xTask 가 참조하는 작업을 차단됨 상태에서 강제 종료한다. */
	if (xTaskAbortDelay (xTask) == pdFAIL)
	{
		/* xTask 가 참조하는 작업은 Blocked 상태가 아니다. */
	}
	else
	{
		/* xTask 가 참조하는 작업은 Blocked 상태였지만 지금은 아니다. */
	}
}

Listing 6. xTaskAbortDelay() 의 사용 예



2.4 xTaskCallApplicationTaskHook()

#include "FreeRTOS.h"
#include "task.h"

BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameters );

Listing 7. xTaskCallApplicationTaskHook() function 프로토타입



Summary

이 기능은 고급 사용자를 대상으로한다.

vTaskSetApplicationTaskTag() 함수를 사용하여 'tag' 값을 작업에 할당 할 수 있다.
tag 값의 의미와 사용은 응용 프로그램 작성자가 정의한다.
커널 자체는 일반적으로 tag 값에 접근하지 않는다.

특수한 경우로 tag 값을 사용하여 'task hook'(또는 callback) 함수를 작업에 연결할 수 있다. 
이 작업이 끝나면 xTaskCallApplicationTaskHook() 을 사용하여 hook 함수가 호출된다.

Task Hook 기능은 어떤 목적으로든 사용될 수 있다.
이 절에 표시된 예제는 디버그 추적 정보를 출력하는데 사용되는 Task 훅을 보여준다.

Task Hook 함수는 Listing 8에 표시된 프로토 타입을 가져야한다.

BaseType_t xAnExampleTaskHookFunction (void * pvParameters);

Listing 8. 모든 Task Hook 함수가 준수해야하는 프로토타입

xTaskCallApplicationTaskHook() 은 FreeRTOSConfig.h 에서
configUSE_APPLICATION_TASK_TAG 가 1 로 설정된 경우에만 사용할 수 있다.

Parameters

xTask

연결된 Hook 기능이 호출되고있는 Task 의 Handle.

Task 의 Handle 을 얻으려면 xTaskCreate() 를 사용하여 작업을 만들고
pxCreatedTask 매개 변수를 사용하거나 xTaskCreateStatic() 을 사용하여
작업을 만들고 반환 된 값을 저장하거나 xTaskGetHandle() 을 호출 할 때 작업 이름을 사용한다.

Task 는 유효한 Task Handle 대신 NULL 을 전달하여 자체 Hook 기능을 호출 할 수 있다.

pvParameters

Task Hook 함수 자체에 대한 매개 변수로 사용되는 값.

이 매개 변수에는 Task Hook 함수 매개 변수를 효과적으로 허용하고
유형에 관계없이 간접적으로 캐스팅을 사용하는 'void 포인터' 유형이 있다.
예를 들어, 정수 타입은 Hook 함수가 호출된 지점에서 void 포인터로 정수를 캐스팅한 후
void 포인터 매개 변수를 후크 함수 자체의 정수로 다시 캐스팅함으로써 Hook 함수로 전달 될 수 있다.



Example

/* Listing 8 에 나와있는 필수 프로토타입을 사용항 Hook(Callback) 함수를 정의한다. */
정적 BaseType_t prvExampleTaskHook (void * pvParameter)
{
	/ * 행동을 취하라 - 이것은 무엇이나 될 수 있다.
	    이 예에서 Hook Debug Trace 정보를 출력하는데 사용된다.
	    pxCurrentTCB 는 현재 실행중인 Task 의 Handle 이다.
	    vWriteTrace() 는 API 함수가 아니며 단순히 예제로 사용되었을 뿐이다. */
	vWriteTrace (pxCurrentTCB);
	/* 이 예제는 Hook return 값을 사용하지 않으므로 모든 경우에 0 을 반환한다. */
}

/* tag 값을 사용하는 예제 Task 를 정의한다. */
void vAnotherTask (void * pvParameters)
{
	/* vTaskSetApplicationTaskTag() 는 Task 와 연관된 'tag' 값을 설정한다.
	   유효한 Task Handle 대신 NULL 이 설정되어
	   호출하는 Task 의 tag 값이어야함을 나타낸다.
	   이 예에서 'value' 는 Hook 함수다. */
	vTaskSetApplicationTaskTag (NULL, prvExampleTaskHook);

	for (;;)
	{
		/ * 나머지 작업 코드는 여기에 있다. * /
	}
}

/ * 전환된 각 Task 의 Hook 기능을 호출하려면
    traceTASK_SWITCHED_OUT() 매크로를 정의하라.
    pxCurrentTCB 는 현재의 실행중인 Task 의 Handle 을 가리 킨다. */
#define traceTASK_SWITCHED_OUT () xTaskCallApplicationTaskHook (pxCurrentTCB, 0)

Listing 9. xTaskCallApplicationTaskHook() 의 사용 예



2.5 xTaskCheckForTimeOut()

#include “FreeRTOS.h”
#include “task.h”

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );

Listing 10. xTaskCheckForTimeOut() function prototype



Summary

이 기능은 고급 사용자를 대상으로한다.

Task 는 Block 된 상태로 전환하여 이벤트를 기다릴 수 있다.
일반적으로 Task 는 Blocked 상태에서 무기한 대기하지 않지만 시간 초과 기간은 지정된다.
Task 가 대기중인 이벤트가 발생하기 전에 제한 시간이 만료되면 Task 가 Blocked 상태에서 제거된다.

Task 가 발생하기를 기다리는 동안 Task 가 Blocked 상태로 두 번 이상 들어가고 나가면
Task 가 Blocked 상태로 전환 될 때마다 사용된 시간 제한을 조정하여
Blocked 상태에서 소요 된 시간의 합계를 조정해야.
원래 지정된 시간 제한을 초과하지 않아야한다.
xTaskCheckForTimeOut() 은 틱 카운트 오버 플로우와 같은 비정기적인 상황을 고려하여 조정을 수행한다.
그렇지 않으면 수동 조정으로 인해 오류가 발생하기 쉽다.

xTaskCheckForTimeOut() 은 vTaskSetTimeOutState() 와 함께 사용된다.
vTaskSetTimeOutState() 를 호출하여 초기 조건을 설정 한 후 xTaskCheckForTimeOut() 을 호출하여
시간 초과 조건을 확인하고 시간 초과가 발생하지 않은 경우 나머지 블록 시간을 조정할 수 있다.

Parameters

- pxTimeOut
Timeout 이 발생했는지를 결정하는데 필요한 정보를 담고 있는 구조체에 대한 포인터다.
pxTimeOut 은 vTaskSetTimeOutState() 를 사용하여 초기화된다.

- pxTicksToWait
Blocked 상태에서 이미 소비된 시간을 고려하여 전체 Block 시간을 전달하는데 사용된다.
(미세한 딜레이도 놓치지 않겠다는 부분임)

Ruturned value

pdTRUE 가 반환되면 Block 시간이 만료되었고, 주어진 시간을 초과했음을 의미한다.
pdFALSE 가 반환되면 Block 시간이 남아 있으므로, 주어진 시간이 아직 남아있음을 의미한다.



Example

/ * UART Interrupt 로 채워진 Rx 버퍼에서 uxWantedBytes 를 수신하는데 사용되는 Driver Library 함수다.
    Rx 버퍼에 충분한 byte 가 없으면 Task 는 더 많은 데이터가
    Buffer 에 저장되었음을 알릴 때까지 Blocked 상태가 된다.
    여전히 Data 가 충분하지 않으면 Task 는 Blocked 상태로 다시 돌아가고
    xTaskCheckForTimeOut() 은 Blocked 상태에서 소비된 총 시간이
    MAX_TIME_TO_WAIT 를 초과하지 않도록 Block 시간을 다시 계산하는데 사용된다.
    버퍼에 적어도 uxWantedBytes 바이트가 포함되거나 Blocked 상태에서
    소요된 총 시간이 MAX_TIME_TO_WAIT 에 도달할 때까지 이것은 계속된다. * /
size_t xUART_Receive (uint8_t * pucBuffer, size_t uxWantedBytes)
{
	size_t uxReceived = 0;
	TickType_t xTicksToWait = MAX_TIME_TO_WAIT;
	TimeOut_t xTimeOut;
	/ * xTimeOut 을 초기화하라.
	    이것은 이 기능이 입력된 시간을 기록한다. * /
	vTaskSetTimeOutState (& xTimeOut);
	/ * 버퍼가 원하는 byte 수를 채우거나 주어진 시간이 만료될 때까지 반복한다. * /
	while (UART_bytes_in_rx_buffer (pxUARTInstance) <uxWantedBytes)
	{
		/ * 버퍼에 충분한 데이터가 없으므로 이 작업은 Blocked 상태가 된다.
		    Blocked 상태에서 소비한 총 시간이 MAX_TIME_TO_WAIT 를 초과하지 않도록
		    xticksToWait 를 조정하여 지금까지 이 함수 내에서 Blocked 상태로 소비된 시간을 계산한다. * /
		if (xTaskCheckForTimeOut (& xTimeOut, & xTicksToWait)! = pdFALSE)
		{
			/ * 원하는 바이트 수가 사용 가능하기 전에 주어진 시간이 만료되었다.
			    루프를 종료하라. * /
			break;
		}
		/ * 최대 xTicksToWaits 틱까지 기다림으로서 수신 Interrupt 가
		    버퍼에 더 많은 데이터를 배치했음을 알림이 수신될 때까지 기다린다. */
		ulTaskNotifyTake (pdTRUE, xTicksToWait);
	}
	/* uxWantedBytes 를 수신 버퍼에서 pucBuffer 로 읽으려고한다.
	   실제 읽은 바이트 수 (uxWantedBytes보다 작을 수 있음)가 반환된다. */
	uxReceived = UART_read_from_receive_buffer (pxUARTInstance, pucBuffer, uxWantedBytes);
	return uxReceived;
}

Listing 11. vTaskSetTimeOutState() 및 xTaskCheckForTimeOut()의 사용 예제



2.6 xTaskCreate()

#include “FreeRTOS.h”
#include “task.h”

BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, unsigned short usStackDepth,
			void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask );

Listing 12. xTaskCreate() function 프로토타입



Summary

작업의 새 인스턴스를 만든다.

각 Task 에는 Task 상태를 유지하는데 사용되는
RAM (Task 제어 블록 또는 TCB)이 필요하며 Task 에 의해 스택으로 사용된다.
xTaskCreate() 를 사용하여 Task 을 만들면 필요한 RAM 이 FreeRTOS Heap 에 자동으로 할당된다.
xTaskCreateStatic() 을 사용하여 Task 를 만들면 응용 프로그램 작성자가 RAM을 제공하므로 
두 개의 추가 함수 매개 변수가 발생하지만 컴파일 타임에 RAM을 정적으로 할당 할 수 있다.

새로 생성된 Task 는 처음에 준비 상태로 전환되지만
실행할 수 있는 우선 순위가 더 높은 작업이 즉시 실행 상태 작업이된다.

Scheduler 가 시작되기 전후에 Task 를 생성할 수 있다.

Parameters

- pvTaskCode
Task 는 단순히 종료하지 않고 일반적으로 무한 루프로 구현되는 C 함수다.
pvTaskCode 매개 변수는 단순히 Task 를 구현하는 함수(사실상 함수 이름)에 대한 포인터다.

- pcName
Task 를 기술하는 이름이다.
이것은 주로 Debugging 을 돕는데 사용되지만 xTaskGetHandle() 을 호출하여 Task Handle 을 얻을 수도 있다.

App 정의 상수 configMAX_TASK_NAME_LEN 은 문자의 최대 길이(NULL 종결자 포함)를 정의한다.
이 최대값 보다 긴 문자열을 제공하면 문자열이 자동으로 잘린다.

- usStackDepth

각 Task 에는 Task 가 생성될 때 커널이 Task 에 할당하는 고유한 스택이 있다.
usStackDepth 값은 스택을 만드는데 필요한 커널의 크기를 알려준다.

이 값은 스택이 보유할 수 있는 단어 수를 지정하며 바이트 수는 지정하지 않는다.
예를 들어 스택 폭이 4 바이트인 아키텍처에서
usStackDepth가 100으로 전달되면 400 바이트의 스택 공간이 할당된다.(100 * 4 바이트)
스택 깊이에 스택 폭을 곱한 값은 size_t 유형의 변수에 포함될 수 있는 최대 값을 초과하지 않아야한다.

유휴 Task 에 사용되는 스택의 크기는 응용 프로그램 정의 상수인 configMINIMAL_STACK_SIZE에 의해 정의된다. 
선택한 마이크로 컨트롤러 아키텍처에 제공된 데모 애플리케이션에서 이 상수에 할당된 값은
해당 아키텍처의 모든 Task 에 대해 최소한 권장된다.
Task 가 많은 스택 공간을 사용하는 경우 더 큰 값을 지정해야한다.

- pvParameters
Task 함수는 'void to pointer'(void *) 유형의 매개 변수를 허용한다.
pvParameters에 할당된 값은 Task 에 전달되는 값이다.

이 매개 변수에는 Task 매개 변수를 효과적으로 허용하고 캐스팅을 통해
간접적으로 모든 유형의 매개 변수를 받을 수 있도록 'void 형 포인터' 유형이 있다.
예를 들어 정수 유형은 Task 가 작성된 지점에서 정수를 비어있는 포인터로 캐스팅 한 다음
void 함수 매개 변수를 Task 함수 정의 자체의 정수로 다시 캐스팅하여 Task 함수로 전달 될 수 있다.

- uxPriority
Task 를 실행할 우선 순위를 정의한다.
우선 순위는 가장 낮은 우선 순위 인 0 에서 가장 높은 우선 순위인 (configMAX_PRIORITIES - 1)까지 할당할 수 있다.

configMAX_PRIORITIES 는 사용자가 정의한 상수다. 
configUSE_PORT_OPTIMISED_TASK_SELECTION 을 0 으로 설정하면
사용할 수 있는 우선 순위 수에 상한값이 없다
(사용되는 데이터 유형의 한계와 마이크로 컨트롤러에서 사용 가능한 RAM 제외).
가장 낮은 수를 사용하는 것이 좋다.
RAM을 낭비하지 않으려면 우선 순위가 필요하다.

위의 우선순위값 (configMAX_PRIORITIES - 1)을 전달하면
Task 에 할당된 우선 순위가 자동으로 최대값으로 제한된다.

- pxCreatedTask
pxCreatedTask 는 생성되는 Task 에 대한 핸들을 전달하는데 사용할 수 있다.
그런 다음이 Handle 을 사용하여 예로 Task 우선 순위를 변경하거나
Task 를 삭제하는 API 호출에서 Task 를 참조 할 수 있다.

응용 프로그램에서 Task Handle 을 사용하지 않으면 pxCreatedTask를 NULL 로 설정할 수 있다.

Return Values

- pdPASS
작업이 성공적으로 만들어 졌음을 나타낸다.

- errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
FreeRTOS 가 Task 데이터 구조와 스택을 할당하기에
사용할 수있는 힙 메모리가 충분하지 않아서 Task 를 작성할 수 없음을 나타낸다.

heap_1.c, heap_2.c 또는 heap_4.c 가 프로젝트에 포함되면 사용 가능한 Heap 의 총량은
FreeRTOSConfig.h 의 configTOTAL_HEAP_SIZE 에 의해 정의되고
vApplicationMallocFailedHook() 콜백(또는 'hook') 함수를 사용하고
남아있는 Heap 메모리양은 xPortGetFreeHeapSize() API 함수를 사용하여 쿼리할 수 있다.

heap_3.c 가 프로젝트에 포함되면 총 Heap 크기는 링커 구성에 의해 정의된다

Notes

이 함수를 사용하려면 configSUPPORT_DYNAMIC_ALLOCATION 을
FreeRTOSConfig.h 에서 1 로 설정하거나 정의되지 않은 상태로 두어야한다.



Example

/* xStruct 라는 구조체와 xStruct 타입의 변수를 정의하라.
   이것은 단지 Task 함수로 전달되는 매개 변수를 보여주기 위해 사용된다. */
typedef 구조체 A_STRUCT
{
	char cStructMember1;
	char cStructMember2;
} xStruct;

/* Task 매개 변수로 전달할 xStruct 유형의 변수를 정의하라. */
xStruct xParameter = {1, 2};

/* 생성될 Task 를 정의하라.
   Task 를 구현하는 함수의 이름은 아래의 xTaskCreate() 호출에서 첫 번째 매개 변수로 사용된다. */
void vTaskCode (void * pvParameters)
{
	xStruct * pxParameters;
	/* void * 매개 변수를 필요한 유형으로 다시 캐스트한다. */
	pxParameters = (xStruct *) pvParameters;
	/* 이제 매개 변수를 예상대로 접근할 수 있다. */
	if (pxParameters-> cStructMember1! = 1)
	{
		/* 기타 */
	}
	/* 무한 루프에 진입하여 작업 처리를 수행하라. */
	for (;;)
	{
		/* 여기에 Task 코드가 있다. */
	}
}

/ * Task 를 생성하는 함수를 정의하라.
    이것은 스케줄러가 시작되기 전이나 후에 호출 될 수 있다. * /
void vAnotherFunction (void)
{
	TaskHandle_t xHandle;
	/ * Task 를 만든다. * /
	if (xTaskCreate (
		vTaskCode, / * Task 를 구현하는 함수의 포인터. * /
		"데모 작업", / * Task 에 주어진 텍스트 이름. * /
		STACK_SIZE, / * Task 를 위해 생성되어야하는 스택의 크기.
				이것은 바이트가 아니라 words 로 정의된다. * /
		(void *) & xParameter, / * xParameters 에 대한 참조가 작업 매개 변수로 사용된다.
					   컴파일러 경고를 방지하기 위해 void *로 변환됩니다. * /
		TASK_PRIORITY, / * 새로 생성된 Task 에 할당할 우선 순위. * /
		& xHandle / * 생성되는 작업의 핸들은 xHandle() 에 배치된다.
		)! = pdPASS)
	{
		/* 힙 메모리가 부족하여 Task 를 만들수 없다.
		   heap_1.c, heap_2.c 또는 heap_4.c 가 프로젝트에 포함되면
		   vApplicationMallocFailedHook() 콜백(또는 'Hook') 함수를 사용하여 트랩할 수 있으며
		   할당되지 않은 상태로 남아있는 FreeRTOS 힙 메모리의 양을 쿼리할 수 있다.
		   xPortGetFreeHeapSize() API 함수를 사용한다. */
	}
	else
	{
		/* 작업이 성공적으로 생성되었다.
		   핸들은 다른 API 함수에서 사용할 수 있다.(예: Task 우선 순위 변경)
		예를 들어 작업의 우선 순위를 변경합니다. */
		vTaskPrioritySet (xHandle, 2);
	}
}

Listing 13. xTaskCreate() 사용 예제



2.7 xTaskCreateStatic()

#include “FreeRTOS.h”
#include “task.h”

TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
				const char * const pcName,
				uint32_t ulStackDepth,
				void *pvParameters,
				UBaseType_t uxPriority,
				StackType_t * const puxStackBuffer,
				StaticTask_t * const pxTaskBuffer );

Listing 14. xTaskCreateStatic() function prototype



Summary

Task 의 새 인스턴스를 만든다.

각 작업에는 작업 상태를 유지하는 데 사용되는 RAM (작업 제어 블록 또는 TCB)이 필요하며 해당 작업이 
스택으로 사용합니다. xTaskCreate ()를 사용하여 작업을 만들면 필요한 RAM이 FreeRTOS 힙에서 자동으로
할당됩니다. xTaskCreateStatic ()을 사용하여 작업을 만들면 응용 프로그램 작성자가 RAM을 제공하므로 
두 개의 추가 함수 매개 변수가 발생하지만 컴파일 타임에 RAM을 정적으로 할당 할 수 있습니다.

새로 생성 된 작업은 처음에 준비 상태로 전환되지만 실행할 수있는 우선 순위가 더 높은 작업이 없으면 
즉시 실행 상태 작업이됩니다.

스케줄러가 시작되기 전후에 작업을 생성 할 수 있습니다.

매개 변수

pvTaskCode
작업은 단순히 종료하지 않고 일반적으로 무한 루프로 구현되는 C 함수입니다. pvTaskCode 매개 변수는 
단순히 태스크를 구현하는 함수 (사실상 함수 이름)에 대한 포인터입니다.

pcName
작업을 설명하는 이름입니다. 이것은 주로 디버깅을 돕는 데 사용되지만 xTaskGetHandle ()을 호출하여 
작업 핸들을 얻을 수도 있습니다.
응용 프로그램 정의 상수 configMAX_TASK_NAME_LEN은 문자의 최대 길이 (NULL 종결 자 포함)를 
정의합니다.



38p



이 최대 값보다 긴 문자열을 제공하면 문자열이 자동으로 잘립니다.

ulStackDepth
puxStackBuffer 매개 변수는 StackType_t 변수의 배열을 xTaskCreateStatic ()에 전달하는 데 
사용됩니다. ulStackDepth는 배열의 인덱스 수로 설정해야합니다.

pvParameters
태스크 함수는 'void to pointer'(void *) 유형의 매개 변수를 허용합니다. pvParameters에 할당 된 
값은 태스크에 전달되는 값입니다.

이 매개 변수에는 작업 매개 변수를 효과적으로 허용하고 캐스팅을 통해 간접적으로 모든 유형의 매개 
변수를받을 수 있도록 'void to pointer'유형이 있습니다. 예를 들어 정수 유형은 태스크가 작성된 
지점에서 정수를 비어있는 포인터로 캐스팅 한 다음 void 함수 매개 변수를 태스크 함수 정의 자체의 
정수로 다시 캐스팅하여 태스크 함수로 전달 될 수 있습니다.

uxPriority
작업을 실행할 우선 순위를 정의합니다. 우선 순위는 가장 낮은 우선 순위 인 0에서 가장 높은 우선 
순위 인 (configMAX_PRIORITIES - 1)까지 할당 할 수 있습니다.

configMAX_PRIORITIES는 사용자가 정의한 상수입니다. configUSE_PORT_OPTIMISED_TASK_SELECTION을 
0으로 설정하면 사용할 수있는 우선 순위 수에 상한이 없습니다 (사용되는 데이터 유형의 한계와 마이크로 
컨트롤러에서 사용 가능한 RAM 제외). 그러나 가장 낮은 수의를 사용하는 것이 좋습니다. RAM을 낭비하지 
않으려면 우선 순위가 필요합니다.

위의 uxPriority 값 (configMAX_PRIORITIES - 1)을 전달하면 작업에 할당 된 우선 순위가 자동으로 
최대 합법적 인 값으로 제한됩니다.

puxStackBuffer
적어도 ulStackDepth 인덱스를 가진 StackType_t 변수의 배열을 가리켜 야합니다 (위의 ulStackDepth 
매개 변수 참조). 배열은 생성 된 작업의 스택으로 사용되므로 영구적이어야합니다 (함수에 의해 생성 된 
스택 프레임이나 응용 프로그램이 실행될 때 합법적으로 덮어 쓸 수있는 다른 메모리에서는 선언되지 
않습니다).




39p



pxTaskBuffer
StaticTask_t 유형의 변수를 가리켜 야합니다. 변수는 생성 된 작업의 데이터 구조 (TCB)를 유지하는 데 사용되므로 영구적이어야합니다 (함수에 의해 만들어진 스택 프레임 또는 응용 프로그램이 실행될 때 합법적으로 덮어 쓸 수있는 다른 메모리에 선언되지 않아야 함).

반환 값

NULL(없는)
puxStackBuffer 또는 pxTaskBuffer가 NULL이므로 태스크를 작성할 수 없습니다.

다른 값
NULL이 아닌 값이 리턴되면 태스크가 작성되고 리턴 된 값은 작성된 타스크의 핸들입니다.

노트
이 함수를 사용하려면 configSUPPORT_STATIC_ALLOCATION을 FreeRTOSConfig.h에서 1로 설정해야합니다.



40p


Example


 * 생성되는 작업이 스택으로 사용할 버퍼의 크기를 지정합니다. 참고 : 이것은 스택이 보유 할 단어 
수이며 바이트 수는 아닙니다. 예를 들어, 각 스택 항목이 32 비트이고이 값이 100으로 설정된 경우 
400 바이트 (100 * 32 비트)가 할당됩니다. * /
#define STACK_SIZE 200
/ * 생성되는 태스크의 TCB를 보유 할 구조. * /
StaticTask_t xTaskBuffer;
/ * 생성되는 태스크가 스택으로 사용할 버퍼. 이것은 StackType_t 변수의 배열입니다. StackType_t의 
크기는 RTOS 포트에 따라 다릅니다. * /
StackType_t xStack [STACK_SIZE];
/ * 생성되는 작업을 구현하는 함수. * /
void vTaskCode (void * pvParameters)
{
/ * pvParameters 매개 변수에 1이 전달되므로 매개 변수 값은 1로 예상됩니다.
xTaskCreateStatic ()에 대한 호출에서. * /
configASSERT ((uint32_t) pvParameters == 1UL);
for (;;)
{
/ * 여기에 작업 코드가 있습니다. * /
}
}
/ * 태스크를 생성하는 함수. * /
void vFunction (void)
{
TaskHandle_t xHandle = NULL;
/ * 동적 메모리 할당을 사용하지 않고 작업을 만듭니다. * /
xHandle = xTaskCreateStatic (
vTaskCode, / * 태스크를 구현하는 함수. * /
"NAME", / * 작업의 텍스트 이름입니다. * /
STACK_SIZE, / * xStack 배열에있는 인덱스의 수. * /
(void *) 1, / * 태스크에 전달 된 매개 변수. * /
tskIDLE_PRIORITY, / * 작업이 생성되는 우선 순위. * /
xStack, / * 태스크의 스택으로 사용할 배열. * /
& xTaskBuffer); / * 작업의 데이터 구조를 유지하는 변수. * /
/ * puxStackBuffer 및 pxTaskBuffer가 NULL이 아니므로 작업이 만들어 졌을 것입니다.
xHandle이 작업의 핸들이됩니다. 핸들을 사용하여 작업을 일시 중단하십시오. * /
vTaskSuspend (xHandle);
}
Listing 15 xTaskCreateStatic ()의 사용 예제




41p


2.8 xTaskCreateRestricted()


#include “FreeRTOS.h”
#include “task.h”
BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition,
TaskHandle_t *pxCreatedTask );
Listing 16 xTaskCreateRestricted() function prototype


개요

이 기능은 고급 사용자를 대상으로하며 FreeRTOS MPU 포트 (메모리 보호 장치를 사용하는 FreeRTOS 포트)
에만 관련이 있습니다.

새 메모리 보호 장치 (MPU) 제한 작업을 만듭니다.

새로 생성 된 작업은 처음에 준비 상태로 전환되지만 실행할 수있는 우선 순위가 더 높은 작업이 없으면 
즉시 실행 상태 작업이됩니다.

스케줄러가 시작되기 전후에 작업을 생성 할 수 있습니다.

매개 변수
pxTaskDefinition
태스크를 정의하는 구조체를 가리키는 포인터. 이 구조는 참조 설명서의이 절에있는 주석 아래에 설명되어 
있습니다.

pxCreatedTask
pxCreatedTask는 생성되는 작업에 대한 핸들을 전달하는 데 사용할 수 있습니다. 그런 다음이 핸들을 
사용하여 예를 들어 태스크 우선 순위를 변경하거나 태스크를 삭제하는 API 호출에서 태스크를 
참조 할 수 있습니다.

응용 프로그램에서 작업 핸들을 사용하지 않으면 pxCreatedTask를 NULL로 설정할 수 있습니다.

반환 값
pdPASS
작업이 성공적으로 만들어 졌음을 나타냅니다.

다른 값
태스크 데이터 구조를 할당하는 데 사용할 수있는 FreeRTOS 힙 메모리가 충분하지 않기 때문에 태스크를 
지정된대로 작성할 수 없음을 나타냅니다.



42p


heap_1.c, heap_2.c 또는 heap_4.c가 프로젝트에 포함되어 있으면 사용 가능한 힙의 총량은 
FreeRTOSConfig.h의 configTOTAL_HEAP_SIZE에 의해 정의되며 메모리 할당 실패는 
vApplicationMallocFailedHook () 콜백 (또는 ' hook ') 함수를 사용하고 남아있는 힙 메모리 양은 
xPortGetFreeHeapSize () API 함수를 사용하여 쿼리 할 수 ??있습니다.

heap_3.c가 프로젝트에 포함되면 총 힙 크기는 링커 구성에 의해 정의됩니다.

노트
xTaskCreateRestricted ()는 Listing 17의 두 가지 데이터 구조를 사용한다.

typedef struct xTASK_PARAMTERS
{
TaskFunction_t pvTaskCode;
const 부호있는 char * const pcName;
unsigned short usStackDepth;
void * pvParameters;
UBaseType_t uxPriority;
portSTACK_TYPE * puxStackBuffer;
MemoryRegion_t xRegions [portNUM_CONFIGURABLE_REGIONS];
} TaskParameters_t;
/ * .... 여기서 MemoryRegion_t는 다음과 같이 정의됩니다. * /
typedef struct xMEMORY_REGION
{
void * pvBaseAddress;
부호없는 long ulLengthInBytes;
부호없는 long ulParameters;
} MemoryRegion_t;
Listing 17 xTaskCreateRestricted ()가 사용하는 데이터 구조

Listing 17 구조체 멤버에 대한 설명이 아래에 나와있다.

pvTaskCode에서 uxPriority로
이러한 구조체 멤버는 동일한 이름을 가진 xTaskCreate () API 함수 매개 변수와 같습니다.

표준 FreeRTOS 작업과 달리 보호 된 작업은 사용자 (권한없는) 또는 수퍼바이저 (권한) 모드로 만들 수 
있으며 uxPriority 구조 멤버는이 옵션을 제어하는 ??데 사용됩니다



43p


사용자 모드에서 작업을 생성하기 위해, uxPriority는 작업이 생성 될 우선 순위와 같게 설정됩니다. 
관리자 모드에서 작업을 생성하기 위해 uxPriority는 작업이 생성되고 가장 중요한 비트가 설정된 
우선 순위와 같도록 설정됩니다. 이를 위해 portPRIVILEGE_BIT 매크로가 제공됩니다.

예를 들어 우선 순위 3의 사용자 모드 작업을 만들려면 uxPriority를 ??3으로 설정합니다. 우선 순위 3에서 
감독자 모드 작업을 만들려면 uxPriority를 ??equal (3 | portPRIVILEGE_BIT)로 설정합니다.

puxStackBuffer
xTaskCreate () API 함수는 작성중인 태스크가 사용할 스택을 자동으로 할당합니다. MPU를 사용하여 
부과 된 제한 사항은 xTaskCreateRestricted () 함수가 동일한 작업을 수행 할 수 없다는 것을 의미하며 
대신 생성되는 작업에서 사용되는 스택을 정적으로 할당하고 puxStackBuffer 매개 변수를 사용하여 
xTaskCreateRestricted () 함수에 전달해야합니다.

제한된 작업이 전환 될 때마다 (실행 상태로 전환됨) MPU는 자체 스택에 대한 작업 읽기 및 쓰기 
액세스를 제공하는 MPU 영역을 정의하도록 동적으로 재구성됩니다. 따라서 정적으로 할당 된 작업 스택은 
MPU에 의해 부과 된 크기 및 정렬 제한 사항을 준수해야합니다. 특히 각 영역의 크기와 정렬은 둘 다 
동일한 값의 두 값과 같아야합니다.

스택 버퍼를 정적으로 선언하면 컴파일러 확장을 사용하여 정렬을 관리 할 수 ??있으며 링커가 가능한 한 
효율적으로 수행 할 스택 배치를 처리 할 수 ??있습니다. 예를 들어 GCC를 사용하는 경우 다음 구문을 
사용하여 스택을 선언하고 올바르게 정렬 할 수 있습니다.

char cTaskStack [1024] __attribute __ ((align (1024));
Listing 18 제한된 태스크에서 사용할 수 있도록 올바르게 정렬 된 스택을 정적으로 선언하기

MemoryRegion_t
MemoryRegion_t 구조체의 배열입니다. 각 MemoryRegion_t 구조체는 생성되는 작업에서 사용할 단일 
MPU 메모리 영역을 정의합니다.



44p



Cortex-M3 FreeRTOS-MPU 포트는 portNUM_CONFIGURABLE_REGIONS를 3으로 정의합니다. 작업 생성시 
세 개의 영역을 정의 할 수 있습니다. region은 vTaskAllocateMPURegions () 함수를 사용하여 런타임에 
다시 정의 할 수 있습니다.

pvBaseAddress 및 ulLengthInBytes 멤버는 메모리 영역의 시작과 메모리 영역의 길이로 각각 설명됩니다. 
ulParameters는 태스크가 정의되는 메모리 영역에 액세스하는 방법을 정의하며 다음 값의 비트 OR을 
취할 수 있습니다.

? portMPU_REGION_READ_WRITE
? portMPU_REGION_PRIVILEGED_READ_ONLY
? portMPU_REGION_READ_ONLY
? portMPU_REGION_PRIVILEGED_READ_WRITE
? portMPU_REGION_CACHEABLE_BUFFERABLE
? portMPU_REGION_EXECUTE_NEVER




45p



Example


/ * 생성되는 보호 된 작업에 사용될 스택을 선언하십시오. 스택 정렬은 크기와 일치해야하며 2의 거듭 
제곱이어야합니다. 따라서 128 단어가 스택에 예약 된 경우
(128 * 4) 바이트 경계에 정렬되어야합니다. 이 예제는 GCC 구문을 사용합니다. * /
정적 포트 STACK_TYPE xTaskStack [128] __attribute __ ((aligned (128 * 4)));
/ * 생성되는 보호 된 작업에 의해 액세스 될 배열을 선언하십시오. 과제는
배열에서만 읽을 수 있고 쓰기는 할 수 없습니다. * /
char cReadOnlyArray [512] __attribute __ ((aligned (512)));
/ * 작업을 정의하기 위해 TaskParameters_t 구조체를 채운다 - 이것은 구조체에 전달 된 구조체이다.
xTaskCreateRestricted () 함수. * /
정적 const TaskParameters_t xTaskDefinition =
{
vTaskFunction, / * pvTaskCode * /
"작업", / * pcName * /
128, / * usStackDepth - 단어가 아닌 바이트로 정의됩니다. * /
NULL, / * pvParameters * /
1, / * uxPriority - 우선 순위 1은 사용자 모드에서 시작합니다. * /
xTaskStack, / * puxStackBuffer - 작업 스택으로 사용할 배열입니다. * /
/ * xRegions -이 경우 세 개의 사용자 정의 가능 영역 중 하나만 실제로 사용됩니다.
매개 변수는 읽기 전용 영역을 설정하는 데 사용됩니다. * /
{
/ * 기본 주소 길이 매개 변수 * /
{cReadOnlyArray, 512, portMPU_REGION_READ_ONLY},
{0, 0, 0},
{0, 0, 0},
}
};
void main (void)
{
/ * xTaskDefinition에 정의 된 작업을 만듭니다. NULL은 두 번째 매개 변수로 사용됩니다.
작업 처리가 필요하지 않습니다. * /
xTaskCreateRestricted (& xTaskDefinition, NULL);
/ * 스케줄러를 시작하십시오. * /
vTaskStartScheduler ();
/ 여기 에선 안됩니다! * /
}
Listing 19 xTaskCreateRestricted ()의 사용 예제



46p



2.9 vTaskDelay()

#include “FreeRTOS.h”
#include “task.h”
void vTaskDelay( TickType_t xTicksToDelay );
Listing 20 vTaskDelay() function prototype


개요

vTaskDelay ()를 호출하는 태스크를 일정 수의 틱 세치기의 Blocked 상태에 배치합니다.

0 틱의 지연 기간을 지정해도 호출하는 작업이 차단됨 상태가되는 것은 아니지만 호출하는 작업이 우선 
순위를 공유하는 준비 상태 작업으로 바뀌게됩니다. vTaskDelay (0) 호출은 taskYIELD ()를 
호출하는 것과 같습니다.

매개 변수

xTicksToDelay
호출 한 태스크가 준비 상태로 다시 전환되기 전에 차단 된 상태로 유지되는 틱 인터럽트의 수입니다. 
예를 들어 틱 수가 10,000 일 때 vTaskDelay (100)라는 태스크가 발생하면 틱 계수가 10,100에 도달 
할 때까지 즉시 차단 상태가되어 차단됨 상태가 유지됩니다.

호출되는 vTaskDelay ()와 발생하는 다음 틱 인터럽트 사이에 남아있는 모든 시간은 하나의 완전한 틱 
기간으로 계산됩니다. 따라서 지연 기간을 지정할 때 얻을 수있는 가장 높은 시간 해상도는 최악의 경우 
완전한 틱 인터럽트 기간과 같습니다.

pdMS_TO_TICKS () 매크로는 밀리 초를 틱으로 변환하는 데 사용될 수 있습니다. 이것은이 절의 예에서 
설명됩니다.

반환 값
없음.



47p



노트

vTaskDelay () API 함수를 사용하려면 INRUDE_vTaskDelay를 FreeRTOSConfig.h에서 1로 설정해야합니다.


Example

void vAnotherTask (void * pvParameters)
{
for (;;)
{
/ * 여기에서 약간의 처리를 수행하십시오. * /
...
/ * 20 tick 인터럽트에 대한 Blocked 상태를 입력하십시오 - 실제로 소요 된 시간
Blocked (차단됨) 상태는 틱 주파수에 따라 다릅니다. * /
vTaskDelay (20);
/ * vTaskDelay ()를 처음 호출 한 후 20 ticks가 경과했습니다.
실행. * /
/ * 차단 된 상태를 20 밀리 초 동안 입력하십시오. 사용
pdMS_TO_TICKS () 매크로는 틱 빈도가
차단 된 상태에서 보낸 시간에 영향을줍니다 (
틱 주파수의 해상도). * /
vTaskDelay (pdMS_TO_TICKS (20));
}
}
Listing 21 vTaskDelay () 사용 예제



48p



2.10 vTaskDelayUntil()


#include “FreeRTOS.h”
#include “task.h”
void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, TickType_t xTimeIncrement );
Listing 22 vTaskDelayUntil() function prototype

개요
?
절대 시간에 도달 할 때까지 vTaskDelayUntil ()을 호출 한 작업을 차단됨 상태로 만듭니다.

주기 태스크는 vTaskDelayUntil ()을 사용하여 실행 빈도를 일정하게 유지할 수 있습니다.

vTaskDelay ()와 vTaskDelayUntil ()의 차이점

vTaskDelay ()는 vTaskDelay ()가 호출 된 시간부터 지정된 틱 수 동안 호출 타스크가 Blocked 상태로 진입 한 다음 
Blocked 상태로 남아있게합니다. vTaskDelay ()를 호출 한 태스크가 Blocked 상태를 종료 한 시간은 
vTaskDelay ()가 호출 된 시점을 기준으로합니다.

vTaskDelayUntil ()은 절대 시간에 도달 할 때까지 호출 된 태스크가 Blocked 상태로 들어가고 Blocked 
상태로 남아있게합니다. vTaskDelayUntil ()을 호출 한 태스크는 vTaskDelayUntil ()이 호출되었을 때를 
기준으로 한 시간이 아니라 지정된 시간에 Blocked 상태를 종료합니다.

매개 변수
pxPreviousWakeTime
이 매개 변수의 이름은 vTaskDelayUntil ()이 주기적으로 고정 된 빈도로 실행되는 작업을 구현하는 데 
사용되는 것으로 가정합니다. 이 경우 pxPreviousWakeTime은 작업이 마지막으로 차단됨 상태 ( '깨어나 
기'상태)를 유지 한 시간을 유지합니다. 이 시간은 작업이 다음에 차단됨 상태를 벗어나는 시간을 
계산하기위한 참조 점으로 사용됩니다.

pxPreviousWakeTime이 가리키는 변수는 vTaskDelayUntil () 함수 내에서 자동으로 업데이트됩니다. 
변수가 처음 초기화 될 때를 제외하고는 일반적으로 응용 프로그램 코드에 의해 수정되지 않습니다. 
이 섹션의 예제는 초기화가 수행되는 방법을 보여줍니다.



49p


xTimeIncrement

이 매개 변수는 vTaskDelayUntil ()이 xTimeIncrement 값에 의해 설정된 빈도로 고정 주파수로 
주기적으로 실행되는 작업을 구현하는 데 사용된다는 가정하에 명명됩니다.

xTimeIncrement는 '틱'으로 지정됩니다. pdMS_TO_TICKS () 매크로는 밀리 초를 틱으로 변환하는 데 
사용될 수 있습니다.

반환 값
없음.

노트
vTaskDelay () API 함수를 사용하려면 INCLUDE_vTaskDelayUntil을 FreeRTOSConfig.h에서 1로 
설정해야합니다.




50p




Example


/ * 50 밀리 초마다 작업을 수행하는 작업을 정의하십시오. * /
void vCyclicTaskFunction (void * pvParameters)
{
TickType_t xLastWakeTime;
const TickType_t xPeriod = pdMS_TO_TICKS (50);
/ * xLastWakeTime 변수를 현재 틱으로 초기화해야합니다.
카운트. 이것은 변수가 명시 적으로 기록되는 유일한 시간입니다.
이 할당 후에 xLastWakeTime은 내부적으로 내부적으로 자동 업데이트됩니다.
vTaskDelayUntil (). * /
xLastWakeTime = xTaskGetTickCount ();
/ * 작업 동작을 정의하는 루프를 입력하십시오. * /
for (;;)
{
/ *이 작업은 50 밀리 초마다 실행되어야합니다. 시간 측정
틱. pdMS_TO_TICKS 매크로는 밀리 초 변환하는 데 사용됩니다.
진드기로. xLastWakeTime은 vTaskDelayUntil () 내에서 자동으로 업데이트됩니다.
따라서 작업에 의해 명시 적으로 업데이트되지 않습니다. * /
vTaskDelayUntil (& xLastWakeTime, xPeriod);
/ * 여기에 정기적 인 작업을 수행하십시오. * /
}
}
Listing 23 vTaskDelayUntil ()의 사용 예제



51p


2.11 vTaskDelete()


#include “FreeRTOS.h”
#include “task.h”
void vTaskDelete( TaskHandle_t pxTask );
Listing 24 vTaskDelete() function prototype


개요

xTaskCreate () 또는 xTaskCreateStatic ()에 대한 호출을 사용하여 이전에 작성된 태스크의 인스턴스를 
삭제합니다.

삭제 된 작업은 더 이상 존재하지 않으므로 실행 중 상태가 될 수 없습니다.

삭제 된 작업을 참조하기 위해 작업 핸들을 사용하지 마십시오.

작업이 삭제되면 삭제 된 작업의 스택 및 데이터 구조 (작업 제어 블록)를 보유하는 데 사용 된 메모리를 
해제하는 것이 유휴 작업의 책임입니다. 따라서 응용 프로그램에서 vTaskDelete () API 함수를 사용하는 
경우 응용 프로그램에서 유휴 작업이 처리 시간을 지연시키지 않도록해야합니다 (유휴 작업에는 실행 
상태의 시간이 할당되어야 함).

태스크가 삭제되면 커널 자체에 의해 태스크에 할당 된 메모리 만 자동으로 해제됩니다. 응용 프로그램 
(커널이 아닌)이 타스크에 할당하는 메모리 또는 기타 자원은 타스크를 h 제할 때 응용 프로그램이 명시 
적으로 해제해야합니다.

매개 변수
pxTask
작업의 핸들 (주제 작업)이 삭제된다.

작업의 핸들을 얻으려면 xTaskCreate ()를 사용하여 작업을 만들고 pxCreatedTask 매개 변수를 
사용하거나 xTaskCreateStatic ()을 사용하여 작업을 만들고 반환 된 값을 저장하거나 
xTaskGetHandle ()을 호출 할 때 작업 이름을 사용합니다.

작업은 유효한 작업 핸들 대신 NULL을 전달하여 자체를 삭제할 수 있습니다.

반환 값
없음.



52p



Example


void vAnotherFunction (void)
{
TaskHandle_t xHandle;
/ * 생성 된 작업에 대한 핸들을 xHandle에 저장하여 작업을 만듭니다. * /
만약(
xTaskCreate (
vTaskCode,
"데모 작업",
STACK_SIZE,
없는,
우선 순위,
& xHandle / * xHandle의 주소는 다음과 같이 전달됩니다.
핸들을 얻으려면 xTaskCreate ()에 마지막 매개 변수
생성되는 작업에 적용됩니다. * /
)
! = pdPASS)
{
/ * FreeRTOS 힙이 충분하지 않아서 작업을 만들 수 없습니다
태스크 데이터 구조 및 스택 할당에 사용 가능한 메모리. * /
}
그밖에
{
/ * 방금 생성 된 작업을 삭제하십시오. xTaskCreate ()에서 전달 된 핸들을 사용하십시오.
주제 작업을 참조하십시오. * /
vTaskDelete (xHandle);
}
/ *로 NULL을 전달하여이 함수를 호출 한 태스크를 삭제합니다.
vTaskDelete () 매개 변수. 동일한 작업 (이 작업)은
유효한 핸들을 자체에 전달합니다. * /
vTaskDelete (NULL);
}
Listing 25 vTaskDelete ()의 사용 예제






53~54p



2.12 taskDISABLE_INTERRUPTS()


#include “FreeRTOS.h”
#include “task.h”
void taskDISABLE_INTERRUPTS( void );
Listing 26 taskDISABLE_INTERRUPTS() macro prototype


개요

사용되는 FreeRTOS 포트가 configMAX_SYSCALL_INTERRUPT_PRIORITY (또는 포트에 따라 
configMAX_API_CALL_INTERRUPT_PRIORITY) 커널 구성 상수를 사용하지 않으면 
taskDISABLE_INTERRUPTS ()를 호출하면 인터럽트가 전역 적으로 비활성화됩니다.

사용중인 FreeRTOS 포트가 configMAX_SYSCALL_INTERRUPT_PRIORITY 커널 구성 상수를 사용한다면, 
taskDISABLE_INTERRUPTS ()를 호출하면 다음의 인터럽트 우선 순위와 그 이하의 인터럽트를 남겨 둡니다.
configMAX_SYSCALL_INTERRUPT_PRIORITY가 비활성화되고 모든 우선 순위가 높은 인터럽트가 활성화됩니다.
configMAX_SYSCALL_INTERRUPT_PRIORITY는 일반적으로 FreeRTOSConfig.h에 정의됩니다.

taskDISABLE_INTERRUPTS () 및 taskENABLE_INTERRUPTS ()에 대한 호출은 중첩하도록 설계되지 
않았습니다. 예를 들어, taskDISABLE_INTERRUPTS ()가 두 번 호출되면 taskENABLE_INTERRUPTS ()를 
한 번 호출해도 인터럽트가 활성화됩니다. 중첩이 필요한 경우 taskDISABLE_INTERRUPTS () 및 
taskENABLE_INTERRUPTS () 대신에 taskENTER_CRITICAL () 및 taskEXIT_CRITICAL ()을 사용하십시오.

일부 FreeRTOS API 함수는 API 함수가 호출되기 전에 taskDISABLE_INTERRUPTS ()에 대한 호출로 
인터럽트가 비활성화 된 경우에도 중요한 섹션 중첩 수가 0 인 경우 인터럽트를 다시 활성화하는 중요한 
섹션을 사용합니다. 인터럽트가 이미 해제 된 경우 FreeRTOS API 함수를 호출하는 것은 권장되지 않습니다.

매개 변수
없음.

반환 값
없음.



55p



2.13 taskENABLE_INTERRUPTS()


#include “FreeRTOS.h”
#include “task.h”
void taskENABLE_INTERRUPTS( void );
Listing 27 taskENABLE_INTERRUPTS() macro prototype


개요

작업 ENABLE_INTERRUPTS ()를 호출하면 모든 인터럽트 우선 순위가 활성화됩니다.

taskDISABLE_INTERRUPTS () 및 taskENABLE_INTERRUPTS () 호출은 중첩되도록 설계되지 않았습니다. 
예를 들어, taskDISABLE_INTERRUPTS ()가 두 번 호출되면 taskENABLE_INTERRUPTS ()에 대한 단일 
호출은 여전히 인터럽트가 사용 가능하게됩니다. 중첩이 필요한 경우 taskDISABLE_INTERRUPTS () 및 
taskENABLE_INTERRUPTS () 대신에 taskENTER_CRITICAL () 및 taskEXIT_CRITICAL ()을 사용하십시오.

일부 FreeRTOS API 함수는 API 함수가 호출되기 전에 taskDISABLE_INTERRUPTS ()에 대한 호출로 
인터럽트가 비활성화 된 경우에도 중요한 섹션 중첩 수가 0 인 경우 인터럽트를 다시 활성화하는 
중요한 섹션을 사용합니다. 인터럽트가 이미 해제 된 경우 FreeRTOS API 함수를 호출하는 것은 권장되지 
않습니다.

매개 변수
없음.

반환 값
없음



56p



2.14 taskENTER_CRITICAL()


#include “FreeRTOS.h”
#include “task.h”
void taskENTER_CRITICAL( void );
Listing 28 taskENTER_CRITICAL macro prototype



개요

중요 섹션은 taskENTER_CRITICAL ()을 호출하여 입력 한 후 taskEXIT_CRITICAL ()을 호출하여 
종료됩니다.

taskENTER_CRITICAL ()은 인터럽트 서비스 루틴에서 호출되면 안됩니다. 인터럽트에 상응하는 안전한 
작업은 ITTER_CRITICAL_FROM_ISR ()을 참조하십시오.

taskENTER_CRITICAL () 및 taskEXIT_CRITICAL () 매크로는 인터럽트를 전역 적으로 또는 특정 인터럽트 
우선 순위 수준까지 단순히 비활성화하여 작동하는 기본 중요 섹션 구현을 제공합니다. 인터럽트를 
비활성화하지 않고 중요 섹션을 만드는 방법은 vTaskSuspendAll () API 함수를 참조하십시오.

사용중인 FreeRTOS 포트가 configMAX_SYSCALL_INTERRUPT_PRIORITY 커널 구성 상수를 사용하지 않으면 
taskENTER_CRITICAL ()을 호출하면 인터럽트가 전역 적으로 비활성화됩니다.

사용중인 FreeRTOS 포트가 configMAX_SYSCALL_INTERRUPT_PRIORITY (또는 포트에 따라 
configMAX_API_CALL_INTERRUPT_PRIORITY) 커널 구성 상수를 사용하는 경우 taskENTER_CRITICAL ()을 
호출하면 configMAX_SYSCALL_INTERRUPT_PRIORITY가 설정 한 인터럽트 우선 순위와 그 이하의 인터럽트가 
비활성화되고 모든 우선 순위가 높은 인터럽트가 활성화됩니다 .

Preemptive 컨텍스트 스위치는 인터럽트 내에서만 발생하기 때문에 인터럽트가 비활성화 되어도 발생하지 
않습니다. 따라서 taskENTER_CRITICAL ()을 호출 한 작업은 작업이 명시 적으로 차단 또는 생성하려고 
시도하지 않는 한 중요 섹션이 종료 될 때까지 실행 상태로 유지됩니다 (중요한 섹션 내부에서 
수행해서는 안 됨).



57p



taskENTER_CRITICAL () 및 taskEXIT_CRITICAL ()에 대한 호출은 중첩되도록 설계되었습니다. 따라서 
중요한 섹션은 taskEXIT_CRITICAL ()에 대한 하나의 호출이 taskENTER_CRITICAL ()에 대한 모든 이전 
호출에 대해 실행 된 경우에만 종료됩니다.

중요 섹션은 매우 짧게 유지해야하며, 그렇지 않으면 인터럽트 응답 시간에 부정적인 영향을 미칩니다. 
taskENTER_CRITICAL ()에 대한 모든 호출은 taskEXIT_CRITICAL ()에 대한 호출과 밀접하게 
연결되어야합니다.

FreeRTOS API 함수는 중요한 섹션 내에서 호출되어서는 안됩니다.

매개 변수
없음.

반환 값
없음



58p



Example

/ * 중요한 섹션을 사용하는 함수. * /
void vDemoFunction (void)
{
/ * 임계 구역을 입력하십시오. 이 예제에서이 함수는 그 자체로 호출됩니다.
중요한 섹션 내에서 들어 오면이 중요한 섹션에 들어가면
중첩 깊이는 2입니다. * /
taskENTER_CRITICAL ();
/ * 여기서 중요한 섹션에 의해 보호되는 액션을 수행하십시오. * /
/ * 임계 구역을 종료하십시오. 이 예제에서이 함수는 그 자체로 호출됩니다.
critical 섹션에서 호출되므로 taskEXIT_CRITICAL ()에 대한이 호출은
중첩 횟수가 하나씩 증가하지만 인터럽트가 활성화되지는 않습니다. * /
taskEXIT_CRITICAL ();
}
/ * 중요한 섹션 내에서 vDemoFunction ()을 호출하는 태스크. * /
void vTask1 (void * pvParameters)
{
for (;;)
{
/ * 여기에 일부 기능을 수행하십시오. * /
/ * 중요한 작업 영역을 생성하려면 taskENTER_CRITICAL ()을 호출하십시오. * /
taskENTER_CRITICAL ();
/ * 여기서 중요한 섹션을 필요로하는 코드를 실행합니다. * /
/ * taskENTER_CRITICAL ()에 대한 호출은 중첩 될 수 있으므로
taskENTER_CRITICAL ()에 대한 자체 호출을 포함하는 함수
taskEXIT_CRITICAL (). * /
vDemoFunction ();
/ * 임계 영역을 필요로하는 작업이 완료되었으므로
중요 섹션. 이 taskEXIT_CRITICAL () 호출 후 중첩 깊이
0이되므로 인터럽트가 다시 활성화됩니다. * /
taskEXIT_CRITICAL ();
}
}
Listing 29 taskENTER_CRITICAL () 및 taskEXIT_CRITICAL ()의 사용 예





59p



2.15 taskENTER_CRITICAL_FROM_ISR()


#include “FreeRTOS.h”
#include “task.h”
UBaseType_t taskENTER_CRITICAL_FROM_ISR( void );
Listing 30 taskENTER_CRITICAL_FROM_ISR() macro prototype


개요

인터럽트 서비스 루틴 (ISR)에서 사용할 수있는 taskENTER_CRITICAL () 버전.

ISR에서 중요한 섹션은 taskENTER_CRITICAL_FROM_ISR ()을 호출하여 입력 한 다음 
taskEXIT_CRITICAL_FROM_ISR ()을 호출하여 종료됩니다.

taskENTER_CRITICAL_FROM_ISR () 및 taskEXIT_CRITICAL_FROM_ISR () 매크로는 인터럽트를 전역 적으로 
또는 특정 인터럽트 우선 순위 수준까지 단순히 비활성화하여 작동하는 기본 중요 섹션 구현을 제공합니다.

사용중인 FreeRTOS 포트가 인터럽트 중첩을 지원하면 호출 taskENTER_CRITICAL_FROM_ISR ()은 
configMAX_SYSCALL_INTERRUPT_PRIORITY (또는 configMAX_API_CALL_INTERRUPT_PRIORITY) 커널 구성 
상수에 의해 설정된 인터럽트 우선 순위에서 인터럽트를 비활성화하고 다른 모든 인터럽트 우선 순위는 
활성화 된 상태로 유지합니다. 사용중인 FreeRTOS 포트가 인터럽트 중첩을 지원하지 않으면 
taskENTER_CRITICAL_FROM_ISR () 및 taskEXIT_CRITICAL_FROM_ISR ()은 아무 효과가 없습니다.

taskENTER_CRITICAL_FROM_ISR () 및 taskEXIT_CRITICAL_FROM_ISR ()에 대한 호출은 중첩되도록 
설계되었지만 매크로가 사용되는 방식은 taskENTER_CRITICAL () 및 taskEXIT_CRITICAL ()에 
해당하는 것과 다릅니다.

중요 섹션은 매우 짧게 유지되어야하며, 그렇지 않으면 중첩되는 다른 우선 순위 인터럽트의 응답 시간에 
부정적인 영향을 미칩니다. taskENTER_CRITICAL_FROM_ISR ()에 대한 모든 호출은 
taskEXIT_CRITICAL_FROM_ISR ()에 대한 호출과 밀접하게 연결되어야합니다.


FreeRTOS API 함수는 중요한 섹션 내에서 호출되어서는 안됩니다.




60p


매개 변수
없음.

반환 값

ITTER_CRITICAL_FROM_ISR ()이 호출 된 시점의 인터럽트 마스크 상태가 반환됩니다. 반환 값은 
taskEXIT_CRITICAL_FROM_ISR ()에 일치하는 호출로 전달 될 수 있도록 저장해야합니다.

Example

/ * ISR에서 호출 된 함수. * /
void vDemoFunction (void)
{
UBaseType_t uxSavedInterruptStatus;
/ * 임계 구역을 입력하십시오. 이 예제에서이 함수 자체는에서 호출됩니다.
중요한 섹션 내에서이 중요한 섹션을 입력하면 중첩됩니다.
깊이 2입니다. taskENTER_CRITICAL_FROM_ISR ()에서 반환 한 값을 로컬
스택 변수이므로 taskEXIT_CRITICAL_FROM_ISR ()에 전달할 수 있습니다. * /
uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR ();
/ * 여기서 중요한 섹션에 의해 보호되는 액션을 수행하십시오. * /
/ * 임계 구역을 종료하십시오. 이 예제에서이 함수는
임계 구역이므로 값이 있기 전에 인터럽트가 이미 비활성화되어있을 것입니다.
uxSavedInterruptStatus에 저장되므로 uxSavedInterruptStatus를 전달합니다.
taskEXIT_CRITICAL_FROM_ISR ()은 인터럽트를 다시 활성화하지 않습니다. * /
taskEXIT_CRITICAL_FROM_ISR (uxSavedInterruptStatus);
}
/ * 인터럽트 서비스 루틴 내에서 vDemoFunction ()을 호출하는 태스크. * /
void vDemoISR (void)
{
UBaseType_t uxSavedInterruptStatus;
/ * 중요한 섹션을 생성하기 위해 taskENTER_CRITICAL_FROM_ISR ()을 호출하고,
로컬 스택에 반환 된 값. * /
uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR ();
/ * 여기서 중요한 섹션을 필요로하는 코드를 실행합니다. * /
/ * task에 대한 호출 UNTER_CRITICAL_FROM_ISR ()은 중첩 될 수 있으므로
함수는 taskENTER_CRITICAL_FROM_ISR ()에 대한 자체 호출을 포함하며
taskEXIT_CRITICAL_FROM_ISR (). * /
vDemoFunction ();
/ * 임계 영역을 필요로하는 작업이 완료되었으므로
중요 섹션. 이 ISR에 진입 할 때 인터럽트가 사용되었다고 가정하면,
uxSavedInterruptStatus에 저장하면 인터럽트가 다시 활성화됩니다. * /
taskEXIT_CRITICAL_FROM_ISR (uxSavedInterruptStatus);
}
Listing 31 taskENTER_CRITICAL_FROM_ISR () 및 taskEXIT_CRITICAL_FROM_ISR ()의 사용 예




61p


2.16 taskEXIT_CRITICAL()


#include “FreeRTOS.h”
#include “task.h”
void taskEXIT_CRITICAL( void );
Listing 32 taskEXIT_CRITICAL() macro prototype


개요

중요 섹션은 taskENTER_CRITICAL ()을 호출하여 입력 한 후 taskEXIT_CRITICAL ()을 호출하여 
종료됩니다.

taskEXIT_CRITICAL ()은 인터럽트 서비스 루틴에서 호출되어서는 안됩니다. 인터럽트 안전에 해당하는 
작업은 EXIT_CRITICAL_FROM_ISR ()을 참조하십시오.

taskENTER_CRITICAL () 및 taskEXIT_CRITICAL () 매크로는 인터럽트를 전역 적으로 또는 특정 인터럽트 
우선 순위 수준까지만 비활성화함으로써 작동하는 기본 임계 섹션 구현을 제공합니다.

사용중인 FreeRTOS 포트가 configMAX_SYSCALL_INTERRUPT_PRIORITY 커널 구성 상수를 사용하지 않으면
taskENTER_CRITICAL ()을 호출하면 인터럽트가 전역 적으로 비활성화됩니다.

사용중인 FreeRTOS 포트가 configMAX_SYSCALL_INTERRUPT_PRIORITY 커널 구성 상수를 사용하는 경우, 
taskENTER_CRITICAL ()을 호출하면 configMAX_SYSCALL_INTERRUPT_PRIORITY가 설정 한 인터럽트 우선 
순위와 그 이하의 인터럽트가 비활성화되고 모든 우선 순위가 높은 인터럽트가 활성화됩니다.

Preemptive 컨텍스트 스위치는 인터럽트 내에서만 발생하기 때문에 인터럽트가 비활성화 되어도 발생하지 
않습니다. 따라서 taskENTER_CRITICAL ()을 호출 한 작업은 작업이 명시 적으로 차단 또는 생성하려고 
시도하지 않는 한 중요 섹션이 종료 될 때까지 실행 상태로 유지됩니다 (중요한 섹션 내부에서 
수행해서는 안 됨).

taskENTER_CRITICAL () 및 taskEXIT_CRITICAL ()에 대한 호출은 중첩되도록 설계되었습니다. 따라서 
중요한 섹션은 taskEXIT_CRITICAL ()에 대한 하나의 호출이 taskENTER_CRITICAL ()에 대한 모든 이전 
호출에 대해 실행 된 경우에만 종료됩니다.





62p



중요한 섹션은 매우 짧게 유지해야합니다. 그렇지 않으면 인터럽트 응답 시간에 부정적인 영향을 
미칩니다. taskENTER_CRITICAL ()에 대한 모든 호출은 taskEXIT_CRITICAL ()에 대한 호출과 밀접하게 
연결되어야합니다.

FreeRTOS API 함수는 중요한 섹션 내에서 호출되어서는 안됩니다.

매개 변수
없음.

반환 값
없음.

예
Listing 29를 참조하십시오.




63p


2.1 taskEXIT_CRITICAL_FROM_ISR()


#include “FreeRTOS.h”
#include “task.h”
void taskENTER_CRITICAL_FROM_ISR( UBaseType_t uxSavedInterruptStatus );
Listing 33 taskEXIT_CRITICAL_FROM_ISR() macro prototype

개요

taskENTER_CRITICAL_FROM_ISR ()을 호출하여 입력 된 중요 섹션을 종료합니다.

ISR에서 중요한 섹션은 taskENTER_CRITICAL_FROM_ISR ()을 호출하여 입력 한 다음 
taskEXIT_CRITICAL_FROM_ISR ()을 호출하여 종료됩니다.

taskENTER_CRITICAL_FROM_ISR () 및 taskEXIT_CRITICAL_FROM_ISR () 매크로는 인터럽트를 전역 적으로 
또는 특정 인터럽트 우선 순위 수준까지 단순히 비활성화하여 작동하는 기본 임계 섹션 구현을 제공합니다.

사용중인 FreeRTOS 포트가 인터럽트 중첩을 지원하면 호출 taskENTER_CRITICAL_FROM_ISR ()은 
configMAX_SYSCALL_INTERRUPT_PRIORITY (또는 configMAX_API_CALL_INTERRUPT_PRIORITY) 커널 구성 
상수에 의해 설정된 인터럽트 우선 순위에서 인터럽트를 비활성화하고 다른 모든 인터럽트 우선 순위는 
활성화 된 상태로 유지합니다. 사용중인 FreeRTOS 포트가 인터럽트 중첩을 지원하지 않으면 
taskENTER_CRITICAL_FROM_ISR () 및 taskEXIT_CRITICAL_FROM_ISR ()은 아무 효과가 없습니다.

taskENTER_CRITICAL_FROM_ISR () 및 taskEXIT_CRITICAL_FROM_ISR ()에 대한 호출은 중첩되도록 
설계되었지만 매크로가 사용되는 방식은 taskENTER_CRITICAL () 및 taskEXIT_CRITICAL ()에 해당하는 
것과 다릅니다.

중요 섹션은 매우 짧게 유지되어야하며, 그렇지 않으면 중첩되는 다른 우선 순위 인터럽트의 응답 시간에 부정적인 영향을 미칩니다. taskENTER_CRITICAL_FROM_ISR ()에 대한 모든 호출은 taskEXIT_CRITICAL_FROM_ISR ()에 대한 호출과 밀접하게 연결되어야합니다.

FreeRTOS API 함수는 중요한 섹션 내에서 호출되어서는 안됩니다.



64p



매개 변수

uxSavedInterruptStatus
일치하는 호출에서 반환 된 taskENTER_CRITICAL_FROM_ISR () 값은 uxSavedInterruptStatus 값으로 
사용해야합니다.

반환 값
없음.

예
Listing 31을 참조한다.



65p



2.2 xTaskGetApplicationTaskTag()


#include “FreeRTOS.h”
#include “task.h”
TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask );
Listing 34 xTaskGetApplicationTaskTag() function prototype

개요

태스크와 관련된 '태그'값을 반환합니다. 태그 값의 의미와 사용은 응용 프로그램 작성자가 정의합니다. 
커널 자체는 일반적으로 태그 값에 액세스하지 않습니다.

이 기능은 고급 사용자를 대상으로합니다.

매개 변수

x 태스킹
질의되는 작업의 핸들. 이것이 바로 과제입니다.

태스크는 자신의 태스크 핸들을 사용하거나 유효한 태스크 핸들 대신 NULL을 사용하여 자체 태그 값을 
얻을 수 있습니다.

반환 값

쿼리되는 작업의 '태그'값입니다.

노트

태그 값은 함수 포인터를 보유하는 데 사용될 수 있습니다. 이 작업이 완료되면 
xTaskCallApplicationTaskHook () API 함수를 사용하여 태그 값에 할당 된 함수를 호출 할 수 있습니다. 
이 기술은 실제로 콜백 함수를 태스크에 할당하고 있습니다. 이러한 콜백은 
traceTASK_SWITCHED_IN () 매크로와 함께 사용되어 실행 추적 기능을 구현하는 것이 일반적입니다.

xTaskGetApplicationTaskTag ()를 사용하려면 configRequest_APPLICATION_TASK_TAG를 
FreeRTOSConfig.h에서 1로 설정해야합니다.




66p



Example


/ *이 예에서는 작업 태그 값으로 정수가 설정됩니다. * /
void vATask (void * pvParameters)
{
/ * 현재 실행중인 작업에 태그 값 1을 할당합니다. (void *) 캐스트
컴파일러 경고를 방지하는 데 사용됩니다. * /
vTaskSetApplicationTaskTag (NULL, (void *) 1);
for (;;)
{
/ * 나머지 작업 코드는 여기에 있습니다. * /
}
}
void vAFunction (void)
{
TaskHandle_t xHandle;
long lReturnedTaskHandle;
/ * vATask () 함수에서 작업을 생성하여 생성 된 핸들을 저장한다.
태스크를 xTask 변수에 저장하십시오. * /
/ * 작업을 만듭니다. * /
if (xTaskCreate (
vATask, / * 태스크를 구현하는 함수의 포인터. * /
"데모 작업", / * 작업에 주어진 텍스트 이름. * /
STACK_SIZE, / * 태스크를 위해 생성되어야하는 스택의 크기.
이것은 바이트가 아니라 단어로 정의됩니다. * /
NULL, / * 태스크가 매개 변수를 사용하지 않습니다. * /
TASK_PRIORITY, / * 새로 생성 된 작업에 할당 할 우선 순위. * /
& xHandle / * 생성되는 작업의 핸들은
핸들. * /
) == pdPASS)
{
/ * 작업이 성공적으로 생성되었습니다. 허용 할 단기간 지연
실행할 작업. * /
vTaskDelay (100);
/ * 작업에 할당 된 태그 값은 무엇입니까? 반환 된 태그 값은
정수로 저장되므로 컴파일러 경고를 방지하기 위해 정수로 캐스팅됩니다. * /
lReturnedTaskHandle = (long) xTaskGetApplicationTaskTag (xHandle);
}
}
Listing 35 xTaskGetApplicationTaskTag ()의 사용 예




67p


2.3 xTaskGetCurrentTaskHandle()


#include “FreeRTOS.h”
#include “task.h”
TaskHandle_t xTaskGetCurrentTaskHandle( void );
Listing 36 xTaskGetCurrentTaskHandle() function prototype


개요

실행 중 상태 인 작업의 핸들을 반환합니다.이 핸들은 xTaskGetCurrentTaskHandle ()을 호출 한 작업의 
핸들입니다.

매개 변수
없음.

반환 값
xTaskGetCurrentTaskHandle ()을 호출 한 태스크의 핸들.

노트
xTaskGetCurrentTaskHandle ()을 사용하려면 INCLUDE_xTaskGetCurrentTaskHandle을 
FreeRTOSConfig.h에서 1로 설정해야합니다.



68p



2.4 xTaskGetIdleTaskHandle()


#include “FreeRTOS.h”
#include “task.h”
TaskHandle_t xTaskGetIdleTaskHandle( void );
Listing 37 xTaskGetIdleTaskHandle() function prototype


개요

유휴 작업과 연결된 작업 핸들을 반환합니다. 유휴 작업은 스케줄러가 시작될 때 자동으로 생성됩니다.

매개 변수
없음.

반환 값
유휴 작업의 핸들입니다.

노트
xTaskGetIdleTaskHandle ()을 사용하려면 INCLUDE_xTaskGetIdleTaskHandle을 FreeRTOSConfig.h에서 
1로 설정해야합니다.



69p



2.1 xTaskGetHandle()

#include “FreeRTOS.h”
#include “task.h”
TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );
Listing 38 xTaskGetHandle() function prototype


개요

태스크는 xTaskCreate () 또는 xTaskCreateStatic ()을 사용하여 생성됩니다. 두 함수 모두 사람이 읽을 
수있는 텍스트 이름을 생성중인 작업에 할당하는 데 사용되는 pcName이라는 매개 변수를 가지고 있습니다. xTaskGetHandle ()은 작업의 사람이 읽을 수있는 텍스트 이름을보고 작업의 핸들을 반환합니다.

매개 변수
pcNameToQuery
쿼리되는 작업의 이름입니다. 이름은 표준 NULL로 끝나는 C 문자열로 지정됩니다.

반환 값
태스크가 pcNameToQuery 매개 변수로 지정된 것과 정확히 같은 이름을 갖는 경우 태스크의 핸들이 
리턴됩니다. pcNameToQuery 매개 변수로 지정된 이름을 가진 타스크가 없으면 NULL이 리턴됩니다.

노트
xTaskGetHandle ()을 완료하는 데 비교적 오랜 시간이 걸릴 수 있습니다. 따라서 xTaskGetHandle ()은 
각 작업 이름에 한 번만 사용하는 것이 좋습니다. xTaskGetHandle ()에 의해 반환 된 작업 핸들은 
나중에 다시 사용할 수 있도록 저장할 수 있습니다.

같은 이름을 가진 둘 이상의 태스크가있는 경우 xTaskGetHandle ()의 동작이 정의되지 않았습니다.

xTaskGetHandle ()을 사용하려면 INCLUDE_xTaskGetHandle을 FreeRTOSConfig.h에서 1로 설정해야합니다.



70p



Example


void vATask (void * pvParameters)
{
const char * pcNameToLookup = "MyTask";
TaskHandle_t xHandle;
/ * 이름이 MyTask 인 작업의 핸들을 찾아 반환 된 핸들을 로컬에 저장합니다.
나중에 다시 사용할 수 있습니다. * /
xHandle = xTaskGetHandle (pcNameToLookup);
if (xHandle! = NULL)
{
/ * 작업 핸들이 발견되어 이제 다른 FreeRTOS API에서 사용할 수 있습니다
함수는 TaskHandle_t 매개 변수를 사용합니다. * /
}
for (;;)
{
/ * 나머지 작업 코드는 여기에 있습니다. * /
}
}
Listing 39 xTaskGetHandle ()의 사용 예




71p



2.2 uxTaskGetNumberOfTasks()

#include “FreeRTOS.h”
#include “task.h”
UBaseType_t uxTaskGetNumberOfTasks( void );
Listing 40 uxTaskGetNumberOfTasks() function prototype


개요

uxTaskGetNumberOfTasks ()가 호출 될 때 존재하는 총 작업 수를 반환합니다.

매개 변수
없음.

반환 값
반환 된 값은 uxTaskGetNumberOfTasks ()가 호출 될 때 FreeRTOS 커널의 제어하에있는 총 작업 수입니다.
Suspended 상태 작업 수와 Blocked 상태 작업 수, 준비 상태 작업 수 및 유휴 작업 수 및 실행 상태 
작업 수입니다.



72p



2.3 vTaskGetRunTimeStats()

#include “FreeRTOS.h”
#include “task.h”
void vTaskGetRunTimeStats( char *pcWriteBuffer );
Listing 41 vTaskGetRunTimeStats() function prototype

개요

FreeRTOS는 작업 실행 시간 통계를 수집하도록 구성 할 수 있습니다. 태스크 실행 시간 통계는 각 
태스크가 수신 한 처리 시간에 대한 정보를 제공합니다. 수치는 전체 응용 프로그램 실행 시간의 절대 
시간과 백분율로 제공됩니다. vTaskGetRunTimeStats () API 함수는 수집 된 런타임 통계를 사람이 
읽을 수있는 테이블 형식으로 지정합니다. 작업 이름, 해당 작업에 할당 된 절대 시간 및 해당 작업에 
할당 된 전체 응용 프로그램 실행 시간의 백분율에 대한 열이 생성됩니다. 유휴 작업을 포함하여 
시스템의 각 작업에 대해 행이 생성됩니다. 출력 예가 그림 1에 나와 있습니다.



                       [그림]



그림 1 vTaskGetRunTimeStats ()를 호출하여 생성 된 테이블의 예

매개 변수

pcWriteBuffer
형식화되고 사람이 읽을 수있는 테이블이 쓰여지는 문자 버퍼에 대한 포인터. 경계 검사가 수행되지 
않으므로 전체 테이블을 보유 할만큼 버퍼가 커야합니다.




73p



반환 값
없음.
노트
vTaskGetRunTimeStats ()는 편의상 제공되는 유틸리티 함수입니다. 커널의 일부로 간주되지 않습니다. 
vTaskGetRunTimeStats ()는 xTaskGetSystemState () API 함수를 사용하여 원시 데이터를 가져옵니다.

vTaskGetRunTimeStats ()를 사용하려면 configGENERATE_RUN_TIME_STATS 및 
configUSE_STATS_FORMATTING_FUNCTIONS 둘 다 FreeRTOSConfig.h에서 1로 설정해야합니다. 
configGENERATE_RUN_TIME_STATS를 설정하면 응용 프로그램에서 다음 매크로를 정의해야합니다.

portCONFIGURE_TIMER_FOR_RUN_TIME_STATS ()

이 매크로는 시간 기반을 생성하는 데 사용되는 주변 장치를 초기화하기 위해 제공되어야합니다. 
런타임 통계에 사용되는 시간 기준은 틱 인터럽트보다 더 높은 해상도를 가져야합니다. 그렇지 않으면 
수집 된 통계가 너무 정확하여 유용하지 않을 수 있습니다. 틱 인터럽트보다 10 배에서 20 배 빠른 
타임베이스를 만드는 것이 좋습니다




74p



portGET_RUN_TIME_COUNTER_VALUE () 또는
portALT_GET_RUN_TIME_COUNTER_VALUE (시간)

이 두 매크로 중 하나는 현재 시간 기준 값을 반환하기 위해 제공되어야합니다. 즉 응용 프로그램이 
선택한 시간축 단위로 실행 된 총 시간입니다. 첫 번째 매크로가 사용되면 현재 시간 기준 값으로 
계산되도록 정의되어야합니다. 두 번째 매크로가 사용되는 경우 'Time'매개 변수를 현재 시간 기준 
값으로 설정하도록 정의해야합니다.

이 매크로는 FreeRTOSConfig.h에서 정의 할 수 있습니다.


Example

/ * LM3Sxxxx Eclipse 데모 애플리케이션에는 이미 20KHz 타이머 인터럽트가 포함되어 있습니다.
인터럽트 핸들러는 단순히 호출 된 변수를 증가시키기 위해 업데이트되었습니다.
ulHighFrequencyTimer는 실행될 때마다 찾습니다.
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS ()는이 변수를 0으로 설정하고
portGET_RUN_TIME_COUNTER_VALUE ()는 해당 값을 반환합니다. 이를 구현하기 위해 다음 몇 줄이 FreeRTOSConfig.h에 추가되었습니다. * /
extern volatile unsigned long ulHighFrequencyTimerTicks;
/ * ulHighFrequencyTimerTicks는 이미 20KHz에서 증가 중입니다. 그냥 설정
그 값은 0으로 돌아 간다. * /
#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS () (ulHighFrequencyTimerTicks = 0UL)
/ * 고주파 카운터 값을 반환하기 만하면됩니다. * /
#define portGET_RUN_TIME_COUNTER_VALUE () ulHighFrequencyTimerTicks
Listing 42 LM3Sxxx Eclipse 데모에서 가져온 예제 매크로 정의




75p



/ * LPC17xx 데모 어플리케이션에는 고주파 인터럽트 테스트가 포함되어 있지 않지만,
그래서 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS ()는 타이머 0을 설정하는데 사용된다.
주변 장치가 시간 기반을 생성합니다. portGET_RUN_TIME_COUNTER_VALUE ()는 단순히 반환합니다.
현재 타이머 0 카운터 값. 이것은 다음 함수를 사용하여 구현되었습니다.
및 매크로. * /
/ * main.c에 정의되어 있습니다. * /
void vConfigureTimerForRunTimeStats (void)
{
const 부호없는 long TCR_COUNT_RESET = 2,
CTCR_CTM_TIMER = 0x00,
TCR_COUNT_ENABLE = 0x01;
/ * 전원을 켜고 타이머에 시계를 넘깁니다. * /
PCONP | = 0x02UL;
PCLKSEL0 = (PCLKSEL0 & (~ (0x3 << 2))) | (0x01 << 2);
/ * 리셋 타이머 0 * /
T0TCR = TCR_COUNT_RESET;
/ * 계산 해봐. * /
T0CTCR = CTCR_CTM_TIMER;
/ * 적절한 프리퀀시를 사용하여 적절한 해상도를 얻을 수 있지만,
항상 너무 많이 오버 플로우하지는 않습니다. * /
T0PR = (configCPU_CLOCK_HZ / 10000UL) - 1UL;
/ * 카운터를 시작하십시오. * /
T0TCR = TCR_COUNT_ENABLE;
}
/ * FreeRTOSConfig.h에 정의되어 있습니다. * /
extern void vConfigureTimerForRunTimeStats (void);
#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS () vConfigureTimerForRunTimeStats ()
#define portGET_RUN_TIME_COUNTER_VALUE () T0TC
Listing 43 LPC17xx Eclipse 데모에서 가져온 예제 매크로 정의


void vAFunction (void)
{
/ * 생성 된 테이블을 저장할만큼 큰 버퍼를 정의하십시오. 대부분의 경우에
버퍼가 너무 커서 스택에 할당 할 수 없으므로이 예에서는
정적이라고 선언했다. * /
정적 char cBuffer [BUFFER_SIZE];
/ * 버퍼를 vTaskGetRunTimeStats ()에 전달하여 데이터 테이블을 생성합니다. * /
vTaskGetRunTimeStats (cBuffer);
/ * 여기에 생성 된 정보를 저장하거나 볼 수 있습니다. * /
}
Listing 44 vTaskGetRunTimeStats ()의 사용 예





76p



2.4 xTaskGetSchedulerState()


#include “FreeRTOS.h”
#include “task.h”
BaseType_t xTaskGetSchedulerState( void );
Listing 45 xTaskGetSchedulerState() function prototype

개요

xTaskGetSchedulerState ()가 호출 될 때 스케줄러가있는 상태를 나타내는 값을 리턴합니다.

매개 변수
없음.

반환 값

taskSCHEDULER_NOT_STARTED
이 값은 vTaskStartScheduler ()가 호출되기 전에 xTaskGetSchedulerState ()가 호출 될 때만 
리턴됩니다.

taskSCHEDULER_RUNNING
스케줄러가 Suspended 상태가 아닌 경우, vTaskStartScheduler ()가 벌써 불려 갔을 경우에 돌려 
주어집니다.

taskSCHEDULER_SUSPENDED
vTaskSuspendAll ()이 호출 되었기 때문에 스케줄러가 Suspended 상태 일 때 리턴됩니다.

노트

xTaskGetSchedulerState ()를 사용하려면 INCLUDE_xTaskGetSchedulerState를 FreeRTOSConfig.h에서 
1로 설정해야합니다.





77p



2.5 uxTaskGetStackHighWaterMark()

#include “FreeRTOS.h”
#include “task.h”
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );


개요

각 작업은 자체 스택을 유지 관리하며 작업의 생성시 전체 크기가 지정됩니다. 
uxTaskGetStackHighWaterMark ()는 태스크가 할당 된 스택 공간을 오버플로하는 정도를 쿼리하는 데 
사용됩니다. 이 값을 스택 최고점이라고합니다.

매개 변수

x 태스킹
스택 최고 수위가 조회되는 태스크의 핸들 (주 태스크).

작업의 핸들을 얻으려면 xTaskCreate ()를 사용하여 작업을 만들고 pxCreatedTask 매개 변수를 
사용하거나 xTaskCreateStatic ()을 사용하여 작업을 만들고 반환 된 값을 저장하거나 
xTaskGetHandle ()을 호출 할 때 작업 이름을 사용합니다.

태스크는 유효한 태스크 핸들 대신 널 (NULL)을 전달하여 고유 한 스택 최고 워터 마크를 조회 할 수 
있습니다.

반환 값
태스크가 사용하는 스택의 양은 태스크가 실행되고 인터럽트가 처리 될 때 커지고 줄어 듭니다. 
uxTaskGetStackHighWaterMark ()는 태스크 실행이 시작된 이후에 사용 가능한 최소 스택 공간의 양을 
반환합니다. 이것은 스택 사용량이 가장 큰 (또는 가장 깊은) 값일 때 사용되지 않은 채로 남아있는 
스택의 양입니다. 상위 워터 마크가 0에 가까울수록 스택 오버플로에 더 가까워집니다.

노트
uxTaskGetStackHighWaterMark ()는 실행하는 데 비교적 오랜 시간이 걸릴 수 있습니다. 따라서 빌드를 
테스트하고 디버그하는 용도로만 사용하는 것이 좋습니다.





78p



uxTaskGetStackHighWaterMark ()를 사용하려면 INCLUDE_uxTaskGetStackHighWaterMark를 
FreeRTOSConfig.h에서 1로 설정해야합니다.

Example

void vTask1 (void * pvParameters)
{
UBaseType_t uxHighWaterMark;
/ * 작업이 시작될 때 호출하는 작업의 최고 수위 표시를 검사합니다.
실행하십시오. * /
uxHighWaterMark = uxTaskGetStackHighWaterMark (NULL);
for (;;)
{
/ * 모든 함수를 호출하십시오. * /
vTaskDelay (1000);
/ * 함수 호출은 일부 스택 공간을 사용하게 될 것이므로
uxTaskGetStackHighWaterMark ()가 더 낮은 값을 반환 할 것으로 예상됩니다.
이 시점에서 태스크 함수에 대한 입력시 호출됩니다. * /
uxHighWaterMark = uxTaskGetStackHighWaterMark (NULL);
}
}
Listing 46 uxTaskGetStackHighWaterMark ()의 사용 예




79



2.6 eTaskGetState()

#include “FreeRTOS.h”
#include “task.h”
eTaskState eTaskGetState( TaskHandle_t pxTask );
Listing 47 eTaskGetState() function prototype


개요

eTaskGetState ()가 실행될 때 작업이 존재하는 상태를 열거 형식으로 반환합니다.

매개 변수
pxTask
대상 작업의 핸들입니다.

작업의 핸들을 얻으려면 xTaskCreate ()를 사용하여 작업을 만들고 pxCreatedTask 매개 변수를 
사용하거나 xTaskCreateStatic ()을 사용하여 작업을 만들고 반환 된 값을 저장하거나 
xTaskGetHandle ()을 호출 할 때 작업의 이름을 사용합니다.

반환 값
표 1은 eTaskGetState ()가 pxTask 매개 변수가 참조 할 수있는 작업이 존재할 수있는 각 가능한 
상태에 대해 반환 할 값을 나열합니다.

표 1. eTaskGetState () 리턴 값

상태              반환 값

Running		eRunning (태스크가 자체 상태를 조회 중)
Ready		eReady
Blocked	        eBlocked
Suspended	eSuspended
Deleted		eDeleted (작업의 구조가 정리 대기 중)




80p


노트

eTaskGetState () API 함수를 사용하려면 INCLUDE_eTaskGetState를 FreeRTOSConfig.h에서 1로 
설정해야합니다.




81p



2.7 uxTaskGetSystemState()


#include “FreeRTOS.h”
#include “task.h”
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
const UBaseType_t uxArraySize,
unsigned long * const pulTotalRunTime );
Listing 48 uxTaskGetSystemState() function prototype


개요

uxTaskGetSystemState ()는 시스템의 각 작업에 대한 TaskStatus_t 구조체를 채 웁니다. 
TaskStatus_t 구조체에는 작업의 핸들, 이름, 우선 순위, 상태 및 소비 된 총 런타임 시간이 포함됩니다.
TaskStatus_t 구조체는 Listing 50에 정의되어있다.

매개 변수

pxTaskStatusArray
TaskStatus_t 구조체의 배열에 대한 포인터. 어레이는 RTOS의 통제하에있는 각 태스크에 대해 하나 
이상의 TaskStatus_t 구조체를 포함해야합니다. RTOS의 제어하에있는 작업의 수는 
uxTaskGetNumberOfTasks () API 함수를 사용하여 결정할 수 있습니다.

uxArraySize
pxTaskStatusArray 매개 변수가 가리키는 배열의 크기입니다. 크기는 배열의 바이트 수가 아닌 배열의 
인덱스 수 (배열에 포함 된 TaskStatus_t 구조체의 수)로 지정됩니다.

pulTotalRunTime
FreeRTOSConfig.h에서 configGENERATE_RUN_TIME_STATS를 1로 설정하면 * pulTotalRunTime은 대상이 
부팅 된 이후 uxTaskGetSystemState ()에 의해 실행 시간 통계 클럭에 정의 된 총 실행 시간으로 
설정됩니다. 전체 실행 시간 값을 생략하려면 pulTotalRunTime을 NULL로 설정할 수 있습니다.



82p


반환 값
uxTaskGetSystemState ()에 의해 채워진 TaskStatus_t 구조체의 수입니다. 이 값은 
uxTaskGetNumberOfTasks () API 함수에 의해 반환 된 숫자와  같아야하지만 uxArraySize 매개 변수에 
전달 된 값이 너무 작 으면 0이됩니다.

노트
이 함수는 스케줄러가 오랜 시간 동안 정지 된 채로 남아 있기 때문에 디버깅 용도로만 사용됩니다.

시스템의 모든 작업 대신 단일 작업에 대한 정보를 얻으려면 uxTaskGetSystemState () 대신 
vTaskGetTaskInfo ()를 사용하십시오.

configUSE_TRACE_FACILITY는 uxTaskGetSystemState ()가 사용 가능하도록 FreeRTOSConfig.h에서 1로 
정의되어야합니다.





83p




Example


/ *이 예제는 인간이 읽을 수있는 실행 시간 통계표
정보는 uxTaskGetSystemState ()에서 제공하는 원시 데이터에서 생성됩니다.
사람이 읽을 수있는 테이블은 pcWriteBuffer에 기록됩니다. (vTaskList ()
실제로 이것을하는 API 함수). * /
void vTaskGetRunTimeStats (부호있는 char * pcWriteBuffer)
{
TaskStatus_t * pxTaskStatusArray;
volatile UBaseType_t uxArraySize, x;
부호없는 long ulTotalRunTime, ulStatsAsPercentage;
/ * 쓰기 버퍼에 문자열이 포함되어 있지 않은지 확인하십시오. * /
* pcWriteBuffer = 0x00;
/ *이 작업이 진행되는 동안 변경 될 수있는 작업 수에 대한 스냅 샷을 만듭니다.
함수가 실행 중입니다. * /
uxArraySize = uxTaskGetNumberOfTasks ();
/ * 각 작업에 대해 TaskStatus_t 구조를 할당합니다. 배열은
컴파일 할 때 정적으로 할당됩니다. * /
pxTaskStatusArray = pvPortMalloc (uxArraySize * sizeof (TaskStatus_t));
if (pxTaskStatusArray! = NULL)
{
/ * 각 작업에 대한 원시 상태 정보를 생성합니다. * /
uxArraySize = uxTaskGetSystemState (pxTaskStatusArray, uxArraySize, & ulTotalRunTime);
/ * 퍼센트 계산. * /
ulTotalRunTime / = 100UL;
/ * 제로 에러로 나누지 마십시오. * /
if (ulTotalRunTime> 0)
{
/ * pxTaskStatusArray 배열의 채워진 각 위치에 대해,
원시 데이터를 사람이 읽을 수있는 ASCII 데이터로 포맷합니다. * /
for (x = 0; x <uxArraySize; x ++)
{
/ * 태스크가 사용 된 총 실행 시간의 몇 퍼센트입니까?
이것은 항상 가장 가까운 정수로 내림됩니다.
ulTotalRunTimeDiv100은 이미 100으로 나눕니다. * /
ulStatsAsPercentage = pxTaskStatusArray [x] .ulRunTimeCounter / ulTotalRunTime;
if (ulStatsAsPercentage> 0UL)
{
sprintf (pcWriteBuffer, "% s \ t \ t % lu \ t \ t % lu %% \ r \ n",
pxTaskStatusArray [x] .pcTaskName,
pxTaskStatusArray [x] .ulRunTimeCounter,
ulStatsAsPercentage);
}
그밖에
{
/ * 여기서 백분율이 0이면 작업에
총 실행 시간의 1 % 미만을 소비했습니다. * /
sprintf (pcWriteBuffer, "% s \ t \ t % lu \ t \ t <1 %% \ r \ n",
pxTaskStatusArray [x] .pcTaskName,
pxTaskStatusArray [x] .ulRunTimeCounter);
}
pcWriteBuffer + = strlen ((char *) pcWriteBuffer);
}
}
/ * 배열은 더 이상 필요하지 않으며, 소비하는 메모리를 비 웁니다. * /
vPortFree (pxTaskStatusArray);
}
}
Listing 49 uxTaskGetSystemState ()의 사용 예제




84p




typedef struct xTASK_STATUS
{
/ * 구조의 나머지 정보가있는 작업의 핸들
관련있다. * /
TaskHandle_t xHandle;
/ * 작업의 이름을 가리키는 포인터. 작업이 삭제 된 경우이 값은 유효하지 않습니다.
구조가 채워지기 때문에! * /
const 부호있는 char * pcTaskName;
/ * 작업에 고유 한 번호. * /
UBaseType_t xTaskNumber;
/ * 구조체가 채워질 때 작업이 존재했던 상태. * /
eTaskState eCurrentState;
/ * 태스크가 실행될 때의 우선 순위 (상속 될 수 있음).
채워졌다. * /
UBaseType_t uxCurrentPriority;
/ * 작업의 현재 우선 순위가 지정된 경우 작업이 반환하는 우선 순위입니다.
뮤텍스를 얻을 때 무한 우선 순위 반전을 피하기 위해 상속됩니다. 유효한 경우에만
configuse_MUTEXES가 FreeRTOSConfig.h에서 1로 정의 된 경우. * /
UBaseType_t uxBasePriority;
/ * 실행 시간 통계에 정의 된대로 지금까지 작업에 할당 된 총 실행 시간
시계. configGENERATE_RUN_TIME_STATS가 1로 정의 된 경우에만 유효합니다.
FreeRTOSConfig.h. * /
부호없는 long ulRunTimeCounter;
/ * 작업 스택 영역의 가장 낮은 주소를 가리 킵니다. * /
StackType_t * pxStackBase;
/ * 작업이 수행 된 이후 작업에 남아있는 스택 공간의 최소 크기
만들어진. 이 값이 0에 가까울수록 작업이 오버플로에 가까워집니다.
그것의 스택. * /
unsigned short usStackHighWaterMark;
} TaskStatus_t;
Listing 50 TaskStatus_t 정의





85p




2.8 vTaskGetTaskInfo()

#include “FreeRTOS.h”
#include “task.h”
void vTaskGetTaskInfo( TaskHandle_t xTask,
TaskStatus_t *pxTaskStatus,
BaseType_t xGetFreeStackSpace,
eTaskState eState );
Listing 51 vTaskGetTaskInfo() function prototype



개요

vTaskGetTaskInfo ()는 단일 태스크에 대한 TaskStatus_t 구조를 채 웁니다. TaskStatus_t 구조체에는 
작업의 핸들, 이름, 우선 순위, 상태 및 소비 된 총 런타임 시간이 포함됩니다.

TaskStatus_t 구조체는 Listing 50에 정의되어있다.

매개 변수
x 태스킹
질의되는 작업의 핸들.
작업의 핸들을 얻으려면 xTaskCreate ()를 사용하여 작업을 만들고 pxCreatedTask 매개 변수를 
사용하거나 xTaskCreateStatic ()을 사용하여 작업을 만들고 반환 된 값을 저장하거나 
xTaskGetHandle ()을 호출 할 때 작업 이름을 사용합니다.

pxTaskStatus
TaskStatus_t 유형의 변수를 가리켜 야하며, 쿼리되는 작업에 대한 정보로 채워집니다.

xGetFreeStackSpace
TaskStatus_t 구조체에는 질의되는 태스크의 상위 워터 마크 스택을보고하는 멤버가 포함됩니다. 
스택 최고 수위 표시는 태스크에 대해 존재했던 최소 스택 공간이므로, 수를 0에 가까울수록 태스크가 
스택 오버플로에 가까워집니다. 스택 최고 수위를 계산하는 데 비교적 오랜 시간이 걸리고 시스템이 
일시적으로 응답하지 않을 수 있으므로 xGetFreeStackSpace 매개 변수가 제공되어 상위 수위 확인을 
건너 뛸 수 있습니다. 높은 워터 마크 값은 xGetFreeStackSpace가 pdFALSE로 설정되지 않은 경우 
TaskStatus_t 구조체에만 기록됩니다.




86p



재산
TaskStatus_t 구조체에는 쿼리되는 작업의 상태를보고하는 멤버가 포함되어 있습니다. 작업 상태를 
얻는 것은 간단한 할당만큼 빠르지 않으므로 eState 매개 변수가 제공되어 TaskStatus_t 구조에서 
상태 정보를 생략 할 수 있습니다. 상태 정보를 얻으려면 eState를 eInvalid로 설정하십시오. 
그렇지 않으면 eState에 전달 된 값이 TaskStatus_t 구조의 작업 상태로보고됩니다.

노트
이 함수는 디버깅 용도로만 사용되므로 잠재적으로 스케줄러가 오랜 시간 동안 정지 된 상태로 남을 수 
있습니다.

시스템의 모든 작업에 대한 TaskStatus_t 구조를 얻으려면 vTaskGetTaskInfo () 대신 
uxTaskGetSystemState ()를 사용하십시오.

configUSE_TRACE_FACILITY는 uxTaskGetSystemState ()가 사용 가능하도록 FreeRTOSConfig.h에서 1로 
정의되어야합니다.

예

void vAFunction (void)
{
TaskHandle_t xHandle;
TaskStatus_t xTaskDetails;
/ * 이름에서 태스크의 핸들을 얻는다. * /
xHandle = xTaskGetHandle ( "Task_Name");
/ * 핸들이 NULL이 아닌지 확인하십시오. * /
configASSERT (xHandle);
/ * 핸들을 사용하여 작업에 대한 추가 정보를 얻습니다. * /
vTaskGetTaskInfo (/ * 조회중인 타스크의 핸들 * /
xHandle,
/ * TaskStatus_t 구조체는 xHandle에 대한 정보를 완성합니다. * /
& xTaskDetails,
/ * TaskStatus_t에 스택 최고 워터 마크 값을 포함시킵니다.
구조. * /
pdTRUE,
/ * TaskStatus_t 구조체에 작업 상태를 포함시킵니다. * /
eInvalid);
}
Listing 52 vTaskGetTaskInfo ()의 사용 예




87p




2.9 pvTaskGetThreadLocalStoragePointer()

#include “FreeRTOS.h”
#include “task.h”
void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
BaseType_t xIndex );
Listing 53 pvTaskGetThreadLocalStoragePointer() function prototype



개요

스레드 로컬 저장소 (또는 TLS)를 사용하면 응용 프로그램 작성자가 작업 제어 블록 내에 값을 저장하고 
작업 자체에 고유 한 값을 만들고 각 작업이 고유 한 값을 가질 수 있습니다.

각 작업에는 스레드 로컬 저장소로 사용할 수있는 자체 포인터 배열이 있습니다. 배열의 인덱스 수는 
FreeRTOSConfig.h의 configNUM_THREAD_LOCAL_STORAGE_POINTERS 컴파일 시간 구성 상수에 의해 
설정됩니다.

pvTaskGetThreadLocalStoragePointer ()는 배열의 인덱스에서 값을 읽어 효과적으로 스레드 로컬 값을 
검색합니다.

매개 변수
xTaskToQuery
스레드 로컬 데이터를 읽는 작업의 핸들
태스크는 NULL을 매개 변수 값으로 사용하여 자체 스레드 로컬 데이터를 읽을 수 있습니다.

xIndex
데이터가 읽히는 thread 로컬 스토리지 배열에 대한 인덱스입니다.

반환 값
태스크의 thread 로컬 스토리지 배열로부터 인덱스 xIndex에 읽어 내진 값.





88p




예
uint32_t ulVariable;
/ * 호출 태스크의 쓰레드 로컬 스토리지의 인덱스 5에 저장된 값을 읽는다.
배열을 ulVariable에 넣습니다. * /
ulVariable = (uint32_t) pvTaskGetThreadLocalStoragePointer (NULL, 5);

Listing 54 pvTaskGetThreadLocalStoragePointer ()의 사용 예





89p




2.10 pcTaskGetName()

#include “FreeRTOS.h”
#include “task.h”
char * pcTaskGetName( TaskHandle_t xTaskToQuery );
Listing 55 pcTaskGetName() function prototype

개요

사람이 읽을 수있는 작업의 텍스트 이름을 쿼리합니다. 텍스트 이름은 태스크를 작성하는 데 사용 된 
xTaskCreate () 또는 xTaskCreateStatic () API 함수 호출의 pcName 매개 변수를 사용하여 태스크에 
지정됩니다.

매개 변수
xTaskToQuery
질의되는 작업의 핸들 (대상 작업).

작업의 핸들을 얻으려면 xTaskCreate ()를 사용하여 작업을 만들고 pxCreatedTask 매개 변수를 
사용하거나 xTaskCreateStatic ()을 사용하여 작업을 만들고 반환 된 값을 저장하거나 
xTaskGetHandle ()을 호출하여 작업의 이름을 사용합니다.

작업은 유효한 작업 핸들 대신 NULL을 전달하여 자체 이름을 쿼리 할 수 있습니다.

반환 값
태스크 이름은 표준 NULL로 끝나는 C 문자열입니다. 반환 된 값은 주 작업 이름에 대한 포인터입니다.





90p



2.11 xTaskGetTickCount()

#include “FreeRTOS.h”
#include “task.h”
TickType_t xTaskGetTickCount( void );
Listing 56 xTaskGetTickCount() function prototype

개요

틱 수는 스케줄러가 시작된 이후 발생한 틱 인터럽트의 총 수입니다. xTaskGetTickCount ()는 현재 
틱 계수 값을 반환합니다.

매개 변수

없음.

반환 값

xTaskGetTickCount ()는 xTaskGetTickCount ()가 호출되었을 때 항상 틱 계수 값을 반환합니다.

노트

틱 구간이 실제로 표시되는 시간은 FreeRTOSConfig.h 내의 configTICK_RATE_HZ에 할당 된 값에 따라 
다릅니다. pdMS_TO_TICKS () 매크로는 밀리 초 단위의 시간을 '틱'시간 단위로 변환하는 데 사용될 수 
있습니다.

결국 틱 수가 오버플로되어 0으로 돌아갑니다. 이것은 커널의 내부 작동에는 영향을 미치지 않습니다. 
예를 들어 작업이 차단됨 상태 일 때 틱 수가 오버 플로우 되더라도 지정된 기간 동안 작업이 항상 
차단됩니다. 그러나 응용 프로그램이 틱 수 값을 직접 사용하는 경우 오버플로는 호스트 응용 프로그램에서
고려해야합니다.

틱 수가 오버플로되는 빈도는 틱 빈도와 카운트 값을 유지하는 데 사용되는 데이터 유형에 따라 다릅니다. configUSE_16_BIT_TICKS가 1로 설정되면 틱 카운트는 16 비트 변수에 보관됩니다. configUSE_16_BIT_TICKS가 0으로 설정된 경우 틱 수는 32 비트 변수에 보관됩니다



91p



Example



void vAFunction (void)
{
TickType_t xTime1, xTime2, xExecutionTime;
/ * 함수가 시작된 시간을 얻는다. * /
xTime1 = xTaskGetTickCount ();
/ * 일부 작업을 수행합니다. * /
/ * 작업 실행 후 시간을 가져옵니다. * /
xTime2 = xTaskGetTickCount ();
/ * 작업 시간은 대략 얼마나 걸립니까? * /
xExecutionTime = xTime2 - xTime1;
}
Listing 57 xTaskGetTickCount ()의 사용 예




92p



Example

void vAFunction (void)
{
TickType_t xTime1, xTime2, xExecutionTime;
/ * 함수가 시작된 시간을 얻는다. * /
xTime1 = xTaskGetTickCount ();
/ * 일부 작업을 수행합니다. * /
/ * 작업 실행 후 시간을 가져옵니다. * /
xTime2 = xTaskGetTickCount ();
/ * 작업 시간은 대략 얼마나 걸립니까? * /
xExecutionTime = xTime2 - xTime1;
}
Listing 57 xTaskGetTickCount ()의 사용 예




92p




2.12 xTaskGetTickCountFromISR()

#include “FreeRTOS.h”
#include “task.h”
TickType_t xTaskGetTickCountFromISR( void );
Listing 58 xTaskGetTickCountFromISR() function prototype




개요

ISR에서 호출 할 수있는 xTaskGetTickCount ()의 버전입니다.

틱 수는 스케줄러가 시작된 이후 발생한 틱 인터럽트의 총 수입니다.

매개 변수

없음.

반환 값
xTaskGetTickCountFromISR ()은 xTaskGetTickCountFromISR ()이 호출 될 때 항상 틱 계수 값을 
반환합니다.

노트
틱 구간이 실제로 표시되는 시간은 FreeRTOSConfig.h 내의 configTICK_RATE_HZ에 할당 된 값에 따라 
다릅니다. pdMS_TO_TICKS () 매크로는 밀리 초 단위의 시간을 '틱'시간 단위로 변환하는 데 사용될 수 
있습니다.

결국 틱 수가 오버플로되어 0으로 돌아갑니다. 이것은 커널의 내부 작동에는 영향을 미치지 않습니다. 
예를 들어 작업이 차단됨 상태 일 때 틱 수가 오버 플로우 되더라도 지정된 기간 동안 작업이 항상 
차단됩니다. 그러나 응용 프로그램이 틱 수 값을 직접 사용하는 경우 오버플로는 호스트 응용 
프로그램에서 고려해야합니다.

틱 수가 오버플로되는 빈도는 틱 빈도와 카운트 값을 유지하는 데 사용되는 데이터 유형에 따라 다릅니다. 
configUSE_16_BIT_TICKS가 1로 설정되면 틱 카운트는 16 비트 변수에 보관됩니다. 
configUSE_16_BIT_TICKS가 0으로 설정된 경우 틱 수는 32 비트 변수에 보관됩니다.




93p



Example



void vAnISR (void)
{
정적 TickType_t xTimeISRLastExecuted = 0;
TickType_t xTimeNow, xTimeBetweenInterrupts;
/ *이 인터럽트가 입력 된 시간을 저장하십시오. * /
xTimeNow = xTaskGetTickCountFromISR ();
/ * 일부 작업을 수행합니다. * /
/ *이 인터럽트와 이전 인터럽트 사이에 얼마나 많은 틱이 발생 했습니까? * /
xTimeBetweenInterrupts = xTimeISRLastExecuted - xTimeNow;
/ *이 인터럽트와 이전 인터럽트 사이에 200 개 이상의 틱이 발생하면
뭔가해라. * /
if (xTimeBetweenInterrupts> 200)
{
/ * 여기서 적절한 조치를 취하십시오. * /
}
/ *이 인터럽트가 입력 된 시간을 기억하십시오. * /
xTimeISRLastExecuted = xTimeNow;
}
Listing 59 xTaskGetTickCountFromISR ()의 사용 예





94p




2.13 vTaskList()

#include “FreeRTOS.h”
#include “task.h”
void vTaskList( char *pcWriteBuffer );
Listing 60 vTaskList() function prototype


개요

vTaskList ()가 호출 될 때 각 작업의 상태를 설명하는 사람이 읽을 수있는 테이블을 문자 버퍼에 
작성합니다. 그림 2에 예가 나와 있습니다.
그림 2 vTaskList ()를 호출하여 생성 된 테이블의 예

이 표에는 다음 정보가 포함되어 있습니다.

? 이름 - 작업을 만들 때 작업에 부여한 이름입니다.

? State - 다음과 같이 vTaskList ()가 호출 될 당시의 작업 상태입니다.

	o 작업이 차단됨 상태이면 'B'.

	o 작업이 준비 상태 인 경우 'R'.

	o 작업이 일시 중지됨 상태이거나 제한 시간없이 차단됨 상태이면 'S'입니다.

	o 작업이 삭제되었지만 유휴 작업이 아직 데이터 구조를 저장하고 스택에 저장하는 데 사용 된 
	  메모리를 해제하지 않은 경우 'D'.

? 우선 순위 - vTaskList ()가 호출 될 때 작업에 할당 된 우선 순위입니다.




95p



? 스택 - 작업 스택의 '최고급 표시'를 표시합니다. 이것은 작업 수명 동안 사용 가능한 최소 여유 
   스택입니다. 이 값이 0에 가까울수록 작업이 스택 오버플로에 가까워집니다.

? 숫자 - 이것은 각 작업에 할당 된 고유 번호입니다. 하나 이상의 작업에 동일한 이름이 지정되었을 때 
   작업을 식별하는 것을 돕는 것 이외의 목적은 없습니다.

매개 변수

pcWriteBuffer
테이블 텍스트가 쓰여지는 버퍼. 이는 경계 검사가 수행되지 않으므로 전체 테이블을 보유 할만큼 충분히 
커야합니다.

반환 값

없음.

노트

vTaskList ()는 편의상 제공되는 유틸리티 함수입니다. 커널의 일부로 간주되지 않습니다. vTaskList ()는 xTaskGetSystemState () 
API 함수를 사용하여 원시 데이터를 가져옵니다.

vTaskList ()는 실행 기간 동안 인터럽트를 비활성화합니다. 하드 실시간 기능이 포함 된 응용 
프로그램에는 적합하지 않을 수 있습니다.

vTaskList ()를 사용하려면 configUSE_TRACE_FACILITY 및 configUSE_STATS_FORMATTING_FUNCTIONS 
둘 다 FreeRTOSConfig.h에서 1로 설정해야합니다.

기본적으로 vTaskList ()는 표준 라이브러리 sprintf () 함수를 사용합니다. 이로 인해 컴파일 된 
이미지 크기와 스택 사용량이 크게 증가 할 수 있습니다. FreeRTOS 다운로드에는 printf-stdarg.c라는 
파일에 sprintf ()의 오픈 소스 버전이 포함되어 있습니다. 표준 라이브러리 인 sprintf () 대신이 
코드를 사용하면 코드 크기의 영향을 최소화 할 수 있습니다. printf-stdarg.c는 FreeRTOS에 대해 
별도로 라이센스가 부여됩니다. 라이선스 조항은 파일 자체에 포함되어 있습니다.
?



96p



Example


void vAFunction (void)
{
/ * 생성 된 테이블을 저장할만큼 큰 버퍼를 정의하십시오. 대부분의 경우에
버퍼가 너무 커서 스택에 할당 할 수 없으므로이 예에서는
정적이라고 선언했다. * /
정적 char cBuffer [BUFFER_SIZE];
/ * 버퍼를 vTaskList ()에 전달하여 정보 테이블을 생성합니다. * /
vTaskList (cBuffer);
/ * 여기에 생성 된 정보를 저장하거나 볼 수 있습니다. * /
}
Listing 61 vTaskList () 사용 예제




97p




2.14 xTaskNotify()
#include “FreeRTOS.h”
#include “task.h”
BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify,
uint32_t ulValue,
eNotifyAction eAction );
Listing 62 xTaskNotify() function prototype


개요

각 작업에는 작업 생성시 0으로 초기화되는 32 비트 알림 값이 있습니다. xTaskNotify ()는 이벤트를 
직접 보내고 잠재적으로 작업을 차단 해제하고 선택적으로 다음 방법 중 하나로 수신 작업의 알림 값을 
업데이트하는 데 사용됩니다.

? 알림 값에 32 비트 숫자 쓰기

? 알림 값 하나 추가 (증가)

? 알림 값에 하나 이상의 비트 설정

? 알림 값을 변경하지 않은 채로 둡니다.

매개 변수

xTaskToNotify
RTOS 태스크의 핸들을 통지 받는다.

작업의 핸들을 얻으려면 xTaskCreate ()를 사용하여 작업을 만들고 pxCreatedTask 매개 변수를 
사용하거나 xTaskCreateStatic ()을 사용하여 작업을 만들고 반환 된 값을 저장하거나 
xTaskGetHandle ()을 호출 할 때 작업 이름을 사용합니다.

ulValue
알림을받는 작업의 알림 값을 업데이트하는 데 사용됩니다. ulValue가 해석되는 방법은 eAction 매개 
변수의 값에 따라 다릅니다.

행동
작업을 알릴 때 수행 할 작업입니다.
eAction은 열거 형이며 다음 값 중 하나를 사용할 수 있습니다.

? ? eNoAction - 작업은 알림을 받지만 알림 값은 변경되지 않습니다. 이 경우 ulValue는 사용되지 
      않습니다.



98p




? eSetBits - 작업의 알림 값은 ulValue와 비트 ORed됩니다. 예를 들어 ulValue가 0x01로 설정된 경우 
   비트 0이 작업의 알림 값 내에 설정됩니다. ulValue가 0x04이면 비트 2가 작업의 알림 값에 
   설정됩니다. eSetBits를 사용하면 작업 통지를 이벤트 그룹에 대한보다 빠르고 가벼운 대안으로 
   사용할 수 있습니다.

? eIncrement - 작업의 알림 값이 1 씩 증가합니다. 이 경우 ulValue는 사용되지 않습니다.

? eSetValueWithOverwrite - 작업의 알림 값은 xTaskNotify ()가 호출 될 때 작업에 이미 보류중인 
   알림이 있어도 무조건 ulValue 값으로 설정됩니다.

? eSetValueWithoutOverwrite - 작업에 이미 보류중인 알림이있는 경우 알림 값이 변경되지 않고 
   xTaskNotify ()가 pdFAIL을 반환합니다. 태스크에 보류중인 알림이 없으면 알림 값은 ulValue로 
   설정됩니다.

반환 값

eAction이 eSetValueWithoutOverwrite로 설정되고 작업의 알림 값이 업데이트되지 않으면 pdFAIL이 
반환됩니다. 다른 모든 경우에는 pdPASS가 리턴됩니다.

노트

태스크의 통지 값이 경량이며 이진 또는 카운팅 세마포어 대신에 더 빠른 대안으로 사용되면 
xTaskNotify () 대신에 더 간단한 xTaskNotifyGive () API 함수를 사용하십시오.

RTOS 태스크 통지 기능은 기본적으로 사용 가능하며 FreeRTOSConfig.h에서 
configUSE_TASK_NOTIFICATIONS를 0으로 설정하여 빌드에서 제외 (태스크 당 8 바이트 저장) 할 수 
있습니다.



99p



Example

Listing 63에서는 다양한 작업을 수행하는 데 사용되는 xTaskNotify ()를 보여 준다.

/ * xTask1Handle이 참조하는 작업의 알림 값에 비트 8을 설정합니다. * /
xTaskNotify (xTask1Handle, (1UL << 8UL), eSetBits);
/ * 잠재적으로 xTask2Handle이 참조하는 작업에 알림을 보냅니다.
차단 된 상태에서 작업을 제거하지만 작업의 업데이트는 수행하지 않습니다.
통지 값. * /
xTaskNotify (xTask2Handle, 0, eNoAction);
/ * xTask3Handle에 의해 참조 된 작업의 통지 값을 0x50으로 설정하고,
작업이 이전 알림 값을 읽지 않았더라도 * /
xTaskNotify (xTask3Handle, 0x50, eSetValueWithOverwrite);
/ * xTask4Handle에서 참조하는 작업의 알림 값을 0xfff로 설정하고,
그렇게 할 경우에만 작업의 기존 알림을 덮어 쓰지 않습니다.
값을 얻었습니다 (xTaskNotifyWait ()를 호출하여)
또는 ulTaskNotifyTake ()). * /
if (xTaskNotify (xTask4Handle, 0xfff, eSetValueWithoutOverwrite) == pdPASS)
{
/ * 작업의 알림 값이 업데이트되었습니다. * /
}
그밖에
{
/ * 작업의 알림 값이 업데이트되지 않았습니다. * /
}

Listing 63 xTaskNotify () 사용 예제




100p



2.15 xTaskNotifyAndQuery()

#include “FreeRTOS.h”
#include “task.h”
BaseType_t xTaskNotifyAndQuery( TaskHandle_t xTaskToNotify,
uint32_t ulValue,
eNotifyAction eAction,
uint32_t *pulPreviousNotifyValue );
Listing 64 xTaskNotifyAndQuery() function prototype


개요

xTaskNotifyAndQuery ()는 xTaskNotify ()와 유사하지만 주 작업의 이전 알림 값이 반환되는 추가 매개 
변수를 포함합니다.

각 작업에는 작업 생성시 0으로 초기화되는 32 비트 알림 값이 있습니다. xTaskNotifyAndQuery ()는 
이벤트를 직접 보내고 잠재적으로 작업을 차단 해제하고 선택적으로 다음 방법 중 하나로 수신 작업의 
알림 값을 업데이트하는 데 사용됩니다.

? 알림 값에 32 비트 숫자 쓰기

? 알림 값 하나 추가 (증가)

? 알림 값에 하나 이상의 비트 설정

? 알림 값을 변경하지 않은 채로 둡니다.

매개 변수

xTaskToNotify
RTOS 태스크의 핸들을 통지 받는다.

작업의 핸들을 얻으려면 xTaskCreate ()를 사용하여 작업을 만들고 pxCreatedTask 매개 변수를 
사용하거나 xTaskCreateStatic ()을 사용하여 작업을 만들고 반환 된 값을 저장하거나 
xTaskGetHandle ()을 호출 할 때 작업 이름을 사용합니다.

ulValue
알림을받는 작업의 알림 값을 업데이트하는 데 사용됩니다. ulValue가 해석되는 방법은 eAction 매개 
변수의 값에 따라 다릅니다.


101p



eAction

작업을 알릴 때 수행 할 작업입니다.

eAction은 열거 형이며 다음 값 중 하나를 사용할 수 있습니다.

? eNoAction - 작업은 알림을 받지만 알림 값은 변경되지 않습니다. 이 경우 ulValue는 사용되지 
   않습니다.

? eSetBits - 작업의 알림 값은 ulValue와 비트 ORed됩니다. 예를 들어 ulValue가 0x01로 설정된 경우 
   비트 0이 작업의 알림 값 내에 설정됩니다. ulValue가 0x04이면 비트 2가 작업의 알림 값에 
   설정됩니다. eSetBits를 사용하면 작업 통지를 이벤트 그룹에 대한보다 빠르고 가벼운 대안으로 
   사용할 수 있습니다.

? eIncrement - 작업의 알림 값이 1 씩 증가합니다. 이 경우 ulValue는 사용되지 않습니다.

? eSetValueWithOverwrite - 작업의 알림 값은 xTaskNotify ()가 호출 될 때 작업에 이미 보류중인 
   알림이 있어도 무조건 ulValue 값으로 설정됩니다.

? eSetValueWithoutOverwrite - 작업에 이미 보류중인 알림이있는 경우 알림 값이 변경되지 않고 
   xTaskNotify ()가 pdFAIL을 반환합니다. 태스크에 보류중인 알림이 없으면 알림 값은 ulValue로 
   설정됩니다.

pulPreviousNotifyValue
xTaskNotifyAndQuery ()의 동작에 의해 비트가 수정되기 전에 주제 작업의 알림 값을 전달하는 데 
사용됩니다.

pulPreviousNotifyValue는 선택적 매개 변수이며 필요하지 않은 경우 NULL로 설정할 수 있습니다. 
pulPreviousNotifyValue가 사용되지 않으면 xTaskNotifyAndQuery () 대신 xTaskNotify ()를 
사용하는 것이 좋습니다.




102p




반환 값
eAction이 eSetValueWithoutOverwrite로 설정되고 작업의 알림 값이 업데이트되지 않으면 pdFAIL이 
반환됩니다. 다른 모든 경우에는 pdPASS가 리턴됩니다.

노트
태스크의 통지 값이 경량이며 이진 또는 카운팅 세마포어 대신에 더 빠른 대안으로 사용되면 
xTaskNotify () 대신에 더 간단한 xTaskNotifyGive () API 함수를 사용하십시오.

RTOS 태스크 통지 기능은 기본적으로 사용 가능하며 FreeRTOSConfig.h에서 
configUSE_TASK_NOTIFICATIONS를 0으로 설정하여 빌드에서 제외 (태스크 당 8 바이트 저장) 할 수 
있습니다.



103p



Example


Listing 65는 다양한 작업을 수행하는 데 사용되는 xTaskNotifyAndQuery ()를 보여줍니다.
uint32_t ulPreviousValue;

/ * xTask1Handle이 참조하는 작업의 알림 값에 비트 8을 설정합니다. 작업의 이전 알림 값은 필요하지 
않으므로 마지막 pulPreviousNotifyValue 매개 변수는 NULL로 설정됩니다. * /
xTaskNotifyAndQuery (xTask1Handle, (1UL << 8UL), eSetBits, NULL);

/ * xTask2Handle이 참조하는 작업에 알림을 보내 잠재적으로 작업을 차단됨 상태에서 제거하지만 작업의 
알림 값은 업데이트하지 않습니다. 작업의 현재 알림 값은 ulPreviousValue에 저장됩니다. * /
xTaskNotifyAndQuery (xTask2Handle, 0, eNoAction, & ulPreviousValue);

/ * 작업이 이전 알림 값을 읽지 않았더라도 xTask3Handle이 참조하는 작업의 알림 값을 0x50으로 
설정합니다. ulPreviousValue에 작업의 이전 알림 값 (0x50으로 설정되기 전에)을 저장합니다. * /
xTaskNotifyAndQuery (xTask3Handle, 0x50, eSetValueWithOverwrite, & ulPreviousValue);

/ * xTask4Handle에서 참조하는 작업의 알림 값을 0xfff로 설정합니다. 작업을 수행하기 전에 
xTaskNotifyWait () 또는 ulTaskNotifyTake ()를 호출하여 작업의 기존 알림 값을 덮어 쓰지 않는 
경우에만 알림 값을 0xfff로 설정합니다. ulPreviousValue에 작업의 이전 알림 값 (0xfff로 설정되기 
전에)을 저장합니다. * /
if (xTaskNotifyAndQuery (xTask4Handle,
0xfff,
eSetValueWithoutOverwrite,
& ulPreviousValue) == pdPASS)
{
/ * 작업의 알림 값이 업데이트되었습니다. * /
}
그밖에
{
/ * 작업의 알림 값이 업데이트되지 않았습니다. * /
}


Listing 65 Example use of xTaskNotifyAndQuery()
